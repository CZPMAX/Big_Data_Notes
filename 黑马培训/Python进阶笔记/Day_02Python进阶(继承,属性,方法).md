# 		面向对象：继承、属性、方法

学习目标：

1. 知道私有权限和公有权限的区别
2. 知道继承的作用
3. 掌握继承的使用，例如：语法格式，单继承、多继承、多层继承
4. 知道子类中如何重写父类中的方法
5. 知道使用super()能够调用父类的同名方法
6. 知道类属性和实例属性的区别
7. 知道实例方法、类方法、静态方法的区别

## 1. 私有权限

学习目标：

1. 知道私有权限和公有权限的区别

------

### 1.1 面向对象的特性

1. 面向对象的的三大特性：**封装、继承、多态**
2. 面向对象的封装特性：
   - 将属性和方法放到一起封装成一个整体，然后通过实例化对象来处理
   - 对类的属性和方法增加访问权限控制

### 1.2 私有属性和私有方法

- 在进行类的定义时，以 `__` 开头的属性称为私有属性，以 `__` 开头的方法称为私有方法

**私有属性**：

- **不能在类定义外部直接通过`对象.属性名`的形式访问，只能在类内部定义的方法中进行访问**

**私有方法**：

- **不能在类定义外部直接通过`对象.方法名(...)`的形式调用，只能在类内部定义的方法中进行调用**

示例代码：

```python
class Dog(object):
    """狗类"""
    def __init__(self, _name, _age):
        # 公用属性：在类定义的外部可以通过`对象名.属性名`进行访问
        self.name = _name
        # 私有属性：在类定义的外部不能通过`对象名.属性名`进行访问
        # __age就是一个私有属性
        self.__age = _age

    # 私有方法：在类定义的外部不能通过`对象名.方法名()`进行调用
    # __pee就是一个私有方法
    def __pee(self):
        print('上厕所嘘嘘')

    def show_info(self):
        # 私有属性在类定义的方法内部可以进行访问
        print(f'我的名字：{self.name}，年龄：{self.__age}')

    def sleep(self):
        # 私有方法在类定义的方法内部可以进行调用
        self.__pee()
        print('睡觉觉zzz')


# 创建一个 Dog 对象
dog1 = Dog('小黑', 2)
print(dog1.name)
# AttributeError: 'Dog' object has no attribute '__age'
# print(dog1.__age)

# AttributeError: 'Dog' object has no attribute '__pee'
# dog1.__pee()

dog1.show_info()
dog1.sleep()
```

执行结果：

```python
小黑
我的名字：小黑，年龄：2
上厕所嘘嘘
睡觉觉zzz
```

### 1.3 私有属性的访问和设置

- **私有属性的目的是为了限制在类的外部直接访问私有属性，增加访问限制**
- 如果想在类的外部进行私有属性的访问和设置，可以提供专门的方法进行私有属性的设置和访问，好处是可以增加一下设置和访问的限制

示例代码：

```python
class Dog(object):
    """狗类"""
    def __init__(self, _name, _age):
        # 公用属性：在类定义的外部可以通过`对象名.属性名`进行访问
        self.name = _name
        # 私有属性：在类定义的外部不能通过`对象名.属性名`进行访问
        # __age就是一个私有属性
        self.__age = _age

    # 私有方法：在类定义的外部不能通过`对象名.方法名()`进行调用
    def __pee(self):
        print('上厕所嘘嘘')

    def get_age(self):
        """返回狗的年龄"""
        return self.__age

    def set_age(self, _age):
        """设置狗的年龄"""
        if _age < 0:
            print('年龄设置非法！')
            return
        self.__age = _age



# 创建一个 Dog 对象
dog1 = Dog('小黑', 3)

result = dog1.get_age() # 通过公开方法 get_age 获取私有属性 __age 的值
print(result)

dog1.set_age(-3) # 通过公开方法 set_age 对私有属性 __age 的值进行设置
result = dog1.get_age()
print(result)
```

执行结果：

```python
3
年龄设置非法！
3
```

### 1.4 私有属性/方法的本质【了解】

- python解释器将私有属性名/私有方法名进行的转换，转换的格式为：`_类名__属性名` 或 `_类名__方法名`
- 在类的外部直接通过原私有属性名/私有方法名是访问不到的，但是通过转换后的名称可以进行访问【不推荐】
- **如果一定要在外部访问，那么只需要在名称前面加上 ‘_类名’ 变成  ‘_类名__名称’**

示例代码：

```python
class Dog(object):
    """狗类"""
    def __init__(self, _name, _age):
        # 公用属性：在类定义的外部可以通过`对象名.属性名`进行访问
        self.name = _name
        # 私有属性：在类定义的外部不能通过`对象名.属性名`进行访问
        # __age就是一个私有属性
        self.__age = _age # python解释器会将 __age 私有属性名转换为 _Dog__age

    # 私有方法：在类定义的外部不能通过`对象名.方法名()`进行调用
    # __pee就是一个私有方法
    def __pee(self): # python解释器会将 __pee 私有方法名转换为 _Dog__pee
        print('上厕所嘘嘘')


# 创建一个 Dog 对象
dog1 = Dog('小黑', 2)

print(dog1._Dog__age)
dog1._Dog__pee()
```

执行结果：

```python
2
上厕所嘘嘘
```

### 1.5 小结

- 知道公有权限和私有权限的区别
  - 2个下划线`__`开头的属性和方法，为私有属性和方法，否则，则为公有的属性和方法
  - 私有权限：只能本类的内部直接访问，不能在类外面直接访问
  - 公有权限：类内部和外部都能直接访问

## 2. 继承介绍

学习目标：

1. 知道继承的作用
2. 知道继承的语法格式

------

### 2.1 继承的概念

#### 2.1.1 生活中的继承

在现实生活中，继承一般指的是子女继承父辈的财产，如下图：

![21_生活中继承](E:\黑马培训\Python进阶笔记\assets\21_生活中继承.png)

#### 2.1.2 程序中的继承

在程序中，继承描述的是指的是类与类之间的关系，如下如所示：

![22_程序中继承](E:\黑马培训\Python进阶笔记\assets\22_程序中继承.png)

- 站在**父类**的角度来看，**父类**派生出**子类**
- 站在**子类**的角度来看，**子类**继承于**父类**
- **父类**也叫**基类**，**子类**也叫**派生类**

### 2.2 继承的作用

- 继承：子类直接具备父类的能力（属性和方法）
- 作用：解决代码重用问题，提高开发效率

### 2.3 继承的语法格式

继承的语法格式：

```python
class 子类名(父类名)：
    pass
```

示例代码：

```python
class Father(object):
    def __init__(self, _money):
        self.money = _money

    def show_money(self):
        print(f'身价：{self.money}')


class Son(Father):
    pass


# 创建一个 Son 对象
son = Son(99999999)
print(son.money)
son.show_money()
```

执行结果：

```python
99999999
身价：99999999
```

**注意：**

- **子类对象调用方法有一个就近原则**
  - **如果本类能找到方法，直接调用本类的方法**
  - **如果本类找不到，则调用父类继承过来的方法**

### 2.4 小结

1. 继承的作用：解决代码重用问题，提高开发效率

2. 继承的语法格式：

   ```python
   class 子类名(父类名)：
       pass
   ```

## 3. 单继承和多继承

学习目标：

1. 知道单继承和多层承的特点

------

### 3.1 单继承

- 单继承：子类只继承一个父类

```python
class Animal(object):
    """动物类"""
    def eat(self):
        print('吃东西')


# Dog 类定义时只继承了 Animal 类
class Dog(Animal):
    """狗类"""
    pass


# 创建一个 Dog 对象
dog1 = Dog()
dog1.eat()
```

### 3.2 多继承

- 多继承：子类定义时同时继承多个父类

  ![51_多继承](E:\黑马培训\Python进阶笔记\assets\51_多继承.png)

多继承语法格式：

```python
class 子类名(父类1, 父类2, ……)：
    pass
```

示例代码：

```python
class SmallDog(object):
    def eat(self):
        print('小口吃东西')

    def sleep(self):
        print('小憩一会')


class BigDog(object):
    def drink(self):
        print('大口喝水')

    def sleep(self):
        print('呼呼大睡')


# SuperDog 类定义时同时继承了 SmallDog 和 BigDog
class SuperDog(SmallDog, BigDog):
    pass


# 创建一个 SuperDog 对象
sd1 = SuperDog()
# SuperDog 从 SmallDog 继承了 eat 方法
sd1.eat()
# SuperDog 从 BigDog 继承了 drink 方法
sd1.drink()
```

执行结果：

```python
小口吃东西
大口喝水
```

**问题：子类继承的多个父类中有多个同名方法，`子类对象.同名方法(...)`调用哪个？**

```python
# 调用哪个 sleep 函数？
# 结论：默认调用先继承的那个父类中的同名方法。
sd1.sleep()
```

执行结果：

```python
小憩一会
```

### 3.3 小结

- 单继承：子类只继承一个父类

- 多继承：子类定义时同时继承多个父类

- 多继承语法格式：

  ```python
  class 子类名(父类1, 父类2, ……)：
      pass
  ```

## 4. 多层继承

学习目标：

1. 知道类的继承具有多层继承传递的效果

------

### 4.1 多层继承

- 继承关系为多层传递，如生活中的爷爷、父亲、儿子

示例代码：

```python
# 爷爷类
class Animal(object):
    """动物类"""
    def eat(self):
        print('吃东西')


# 爸爸类
class Dog(Animal):
    """狗类"""
    def drink(self):
        print('喝水')


# 儿子类
class SuperDog(Dog):
    pass


# 创建一个 SuperDog 对象
sd1 = SuperDog()
sd1.drink()
sd1.eat()
```

运行结果：

```python
喝水
吃东西
```

### 4.2 小结

1. 多层继承：类的继承具有多层继承传递的效果

## 5. 重写父类方法

学习目标：

1. 知道子类中如何重写父类中的方法
2. 知道使用super()能够调用父类的同名方法

------

### 5.1 子类重写父类同名方法

**重写父类(包括爷爷类及以上)方法**：

- 父类(包括爷爷类及以上)的方法不能满足子类的需要，可以对父类(包括爷爷类及以上)的方法重写

**重写的目的**：

- 从父类继承的方法不能满足子类的需要，为了拓展功能而重写

**重写形式**：

- 在子类中定义了一个和父类(包括爷爷类及以上)同名的方法，即为对父类(包括爷爷类 及以上)的方法重写
- **注意：重写之后子类调用同名方法，默认只会调用子类的**

示例代码：

```python
class Animal(object):
    """动物类"""
    def __init__(self):
        print('Animal类中的__init__方法')
        self.type = '动物'

    def show_info(self):
        print(f'Animal类中的show_info方法，类型：{self.type}')


class Dog(Animal):
    def __init__(self):
        """重写父类中的__init__方法"""
        print('Dog类中的 __init__ 方法')
        self.type = '狗'

    def show_info(self):
        """重写父类中的show_info方法"""
        print(f'Dog类中的show_info方法，类型：{self.type}')


# 创建一个 Dog 对象
dog1 = Dog()
dog1.show_info()
```

运行结果：

```python
Dog类中的 __init__ 方法
Dog类中的show_info方法，类型：狗
```

### 5.2 子类调用父类同名方法

子类重写了父类的方法之后，若在子类方法中还想调用父类的同名方法，可以使用如下三种方式：

1. `父类名.同名方法(self, 形参1, ……)`
2. `super(子类名, self).同名方法(形参1, ……)`
3. `super().同名方法(形参1, ……)`：是方法 2 的简写，推荐的写法

示例代码：

```python
class Animal(object):
    """动物类"""
    def __init__(self):
        print('Animal类中的__init__方法')
        self.type = '动物'
        self.age = 1

    def show_info(self):
        print(f'Animal类中的show_info方法，类型：{self.type}')


class Dog(Animal):
    def __init__(self):
        # 调用父类的 __init__ 方法
        # super().__init__()
        print('Dog类中的__init__方法')
        self.type = '狗'

    def show_info(self):
        print(f'Dog类中的show_info方法，类型：{self.type}')

        # 需求：如果在子类的方法中能够调用到父类中的同名 show_info 方法
        # 方式1：父类名.同名方法(self, 形参1, ...)
        Animal.show_info(self)
        # 方式2：super(子类名, self).同名方法(形参1, ...)
        super(Dog, self).show_info()
        # 方式3：super().同名方法(形参1, ...)，方式2的简写
        super().show_info()


# 创建一个 Dog 对象
dog1 = Dog()
# print(dog1.type)
# print(dog1.age)
dog1.show_info()
```

运行结果：

```python
Dog类中的__init__方法
Dog类中的show_info方法，类型：狗
Animal类中的show_info方法，类型：狗
Animal类中的show_info方法，类型：狗
Animal类中的show_info方法，类型：狗
```

### 5.3 多继承中子类调用父类同名方法

#### 5.3.1 类的继承顺序链

查看类的继承顺序链：`类名.__mro__`

示例代码：

```python
class SmallDog(object):
    def eat(self):
        print('吃小东西')


class BigDog(object):
    def eat(self):
        print('啃大骨头')


class SuperDog(SmallDog, BigDog):
    def eat(self):
        print('吃蟠桃')


# 类的继承顺序链：类名.__mro__
print(SuperDog.__mro__)
```

运行结果：

```python
(<class '__main__.SuperDog'>, <class '__main__.SmallDog'>, <class '__main__.BigDog'>, <class 'object'>)
```

#### 5.3.2 多继承中子类调用父类同名方法

子类重写父类方法之后，调用父类同名方法：

1. `父类名.同名方法(self, 形参1, ……)`：调用指定的父类
2. `super(类名, self).同名方法(形参1, ……)`：调用类的继承顺序链上，指定类名的下一个类中的同名方法
3. `super().同名方法(形参1, ……)`：调用先继承父类的同名方法

示例代码：

```python
class SmallDog(object):
    def eat(self):
        print('吃小东西')


class BigDog(object):
    def eat(self):
        print('啃大骨头')


class SuperDog(SmallDog, BigDog):
    def eat(self):
        print('吃蟠桃')

        # 方式1：父类名.同名方法(self, 形参1, ...)
        print('====== 方式1：父类名.同名方法(self, 形参1, ...) ======')
        # 需求1：调用 SmallDog 父类的 eat 方法
        SmallDog.eat(self)
        # 需求2：调用 BigDog 父类的 eat 方法
        BigDog.eat(self)

        # 方式2：super(子类名, self).同名方法(形参1, ...)
        # 方式2的本质：是调用当前类的继承顺序链上，指定类下一个类中的同名方法
        print('====== 方式2：super(子类名, self).同名方法(形参1, ...) ======')
        # 需求1：调用 SmallDog 父类的 eat 方法
        super(SuperDog, self).eat()
        # 需求2：调用 BigDog 父类的 eat 方法
        super(SmallDog, self).eat()

        # 方式3：super().同名方法(形参1, ...)，就是 super(当前类名, self).同名方法(形参1, ...)的简写
        print('====== super().同名方法(形参1, ...) ======')
        # 需求1：调用 SmallDog 父类的 eat 方法
        super().eat()
        # 需求2：调用 BigDog 父类的 eat 方法
        # 注意：方式3不能实现需求2


# 类的继承顺序链：类名.__mro__
# (<class '__main__.SuperDog'>, <class '__main__.SmallDog'>, <class '__main__.BigDog'>, <class 'object'>)
# print(SuperDog.__mro__)

# 创建一个 SuperDog 对象
sd1 = SuperDog()
sd1.eat()
```

运行结果：

```python
吃蟠桃
====== 方式1：父类名.同名方法(self, 形参1, ...) ======
吃小东西
啃大骨头
====== 方式2：super(子类名, self).同名方法(形参1, ...) ======
吃小东西
啃大骨头
====== super().同名方法(形参1, ...) ======
吃小东西
```

#### 5.3.3 小结

1. 子类重写父类同名方法：在子类中定义了一个和父类同名的方法
2. 子类重写父类方法之后，调用父类同名方法：
   - `父类名.同名方法(self, 形参1, ……)`：调用指定的父类
   - `super(类名, self).同名方法(形参1, ……)`：调用类的继承顺序链上，指定类名的下一个类中的同名方法
   - `super().同名方法(形参1, ……)`：调用先继承父类的同名方法

## 6. 私有和继承

学习目标：

1. 知道私有方法、属性不能直接继承使用

------

### 6.1 私有和继承

- 父类中的私有方法、私有属性不能直接被子类继承使用

**如果子类想访问到父类中的私有属性和方法怎么办？**

- 在父类中提供一个公有方法，在父类的公有方法中进行访问私有属性和方法，以此来达到子类能够间接 访问到父类中的私有属性和方法的效果。

```python
class Animal(object):
    """动物类"""
    def __init__(self, _name, _age):
        self.name = _name
        # __age：私有属性
        self.__age = _age

    # __pee：私有方法
    def __pee(self):
        """pee：撒尿"""
        print('上厕所嘘嘘')

    def show_info(self):
        print(f'名字：{self.name}，年龄：{self.__age}')

    def sleep(self):
        # 睡觉撒尿
        self.__pee()
        print('睡觉了💤')


class Dog(Animal):
    """狗类"""
    def test(self):
        # Animal 中的私有属性和方法不能被 Dog 类继承
        # print(self.__age)
        # self.__pee()
        pass


# 创建一个 Dog 对象
dog1 = Dog('旺财', 20)
# dog1.test()
dog1.show_info()
dog1.sleep()
```

运行结果：

```python
名字：旺财，年龄：20
上厕所嘘嘘
睡觉了💤
```

### 6.2 小结

- 父类中的私有方法、私有属性不能直接被子类继承使用

## 7. 多态初理解

学习目标：

1. 理解 python 语言中的多态特点

------

### 7.1 多态

- **多态：多种形态，同一个代码，由于传递的实例对象的不同，最终代码调用有不同的结果，这就叫多态**
- 因为Python是动态语言，站在用户的角度，本身就是多态，不存在非多态的情况

示例代码：

```python
class PayClass(object):
    """支付类"""
    def pay(self):
        """付款"""
        pass

    def refund(self):
        """退款"""
        pass


class Alipay(PayClass):
    """支付宝类"""
    def pay(self):
        print('支付宝付款')

    def refund(self):
        print('支付宝退款')


class WeChat(PayClass):
    """微信支付类"""
    def pay(self):
        print('微信付款')

    def refund(self):
        print('微信退款')


def func(obj):
    # ap1.pay()
    # wc1.pay()
    # 同一个代码，由于传递的实例对象的不同，最终代码调用有不同的结果，这就叫多态
    obj.pay()


ap1 = Alipay()
wc1 = WeChat()
func(ap1) # 结果：'支付付款'
func(wc1) # 结果：'微信付款'
```

### 7.2 小结

- python 中的多态：同一个代码，由于传递的实例对象的不同，最终代码调用有不同的结果。

## 8. 实例属性、类属性

学习目标：

1. 知道类属性的定义方式
2. 知道类属性和实例属性的区别

------

### 8.1 实例属性和类属性

#### 8.1.1 专业名词说明

- 在Python中 "万物皆对象"
- 通过类创建的对象 又称为 **实例对象**，**对象属性 又称为 实例属性**
- 类本身也是一个对象，执行class语句时会被创建，称为 **类对象**，为了和实例对象区分开来，我们习惯叫类

#### 8.1.2 实例属性

- 通过在`__init__`方法里面给实例对象添加的属性

- 在类的外面，直接通过实例对象添加的属性

- **实例属性**必须通过**实例对象**才能访问

- ![image-20220815183912583](E:\黑马培训\Python进阶笔记\assets\image-20220815183912583.png)

  ```python
  # 定义类
  class 类名(object):
      def __init__(self):
          self.实例属性1 = 值1
          self.实例属性2 = 值2
  
  # 创建实例对象
  实例对象名 = 类名()
  
  # 添加属性
  实例对象名.实例属性3 = 值3
  ```

#### 8.1.3 类属性

- 类属性就是 **类对象(也就是类)** 所拥有的属性，它被 **该类的所有实例对象 所共有**。

- 定义在**类里面，类方法外面**的变量就是**类属性**

- 类属性可以使用 **类名** 或 **实例对象** 访问，**推荐使用类名访问**

  ```python
  # 定义类
  class 类名(object):
      类属性1 = 值1
  
      def __init__(self):
          pass
  ```

#### 8.1.4 示例代码

示例代码：

```python
class Dog(object):
    """狗类"""
    # 类属性
    count = 0

    def __init__(self, _name, _age):
        """狗类的实例对象初始化方法"""
        self.name = _name
        self.age = _age


print('========== 华丽分割线 ==========')

# 创建一个 Dog 类的实例对象
dog1 = Dog('小黑', 2)
# 访问实例对象的属性，只能通过`对象名.属性名`的形式进行访问
print(dog1.name)
print(dog1.age)

# 再创建一个 Dog 类的实例对象
dog2 = Dog('旺财', 1)
print(dog2.name)
print(dog2.age)

print('========== 华丽分割线 ==========')

# 访问类属性：`类名.类属性名` 或 `实例对象.类属性名`【不推荐】
print(Dog.count)
print(dog1.count) # 【不推荐】
print(dog2.count) # 【不推荐】
```

运行结果：

```python
========== 华丽分割线 ==========
小黑
2
旺财
1
========== 华丽分割线 ==========
0
0
0
```

注意：

- 类属性就是 **类对象（也就是类）** 所拥有的属性，它被 **该类的所有实例对象 所共有**。
- **实例属性** 是属于每个实例对象的，不同实例对象有各自的内存空间，互不影响。

### 8.2 类属性的作用

**类属性有什么用？**

- **记录一类事物共同需要保存的内容**
- **需求：记录一共创建了多少只狗的实例对象？**

示例代码：

```python
class Dog(object):
    """狗类"""
    # 类属性
    count = 0

    def __init__(self, _name, _age):
        """狗类的实例对象初始化方法"""
        self.name = _name
        self.age = _age

        # 记录创建了多少只狗的实例对象
        # __init__ 方法被调用一次，就说明创建了一个狗的实例对象
        Dog.count += 1


dog1 = Dog('小黑', 2)
print(Dog.count)

dog2 = Dog('旺财', 1)
print(Dog.count)

dog3 = Dog('大白', 3)
print(Dog.count)
```

运行结果：

```python
1
2
3
```

![image-20220815093923250](E:\黑马培训\Python进阶笔记\assets\image-20220815093923250.png)

**类属性的值会一直保存在类中,不会随着对象的改变而改变**

### 8.3 实例属性/类属性注意点

#### 8.3.1 类属性和实例属性同名

- **如果类属性和实例属性同名，实例对象只能操作实例属性**
- 结论：**操作类属性建议使用类名**，避免不必要的麻烦

示例代码：

```python
class Dog(object):
    """狗类"""
    # 类属性
    count = 0

    def __init__(self):
        # 实例属性
        self.count = 1


# 访问类属性 count
print(Dog.count)

# 创建一个 Dog 对象
dog1 = Dog()
# 注意：此处通过 dog1 对象只能访问到实例属性 count
print(dog1.count)
```

运行结果：

```python
0
1
```

#### 8.3.2 修改类属性

- **类属性只能通过`类名.类属性名=值`的方式修改，不能通过实例对象修改**

示例代码：

```python
class Dog(object):
    """狗类"""
    # 这是一个类属性
    count = 0

    def __init__(self, _name, _age):
        self.name = _name
        self.age = _age


# 注意：只能通过`类名.类属性名`修改类属性
Dog.count = 1
print(Dog.count) # 结果为：1

# 注意：不能通过`对象名.类属性名`修改类属性
dog1 = Dog('小黄', 2)
# 此处是给 dog1 对象添加了一个实例属性：count，和类属性同名
dog1.count = 3
# 提示：此处访问的是 dog1 对象的实例属性：count，不是类属性：count
print(dog1.count) # 结果为：3
print(Dog.count) # 结果为：1
```

运行结果：

```python
1
3
1
```

#### 8.3.3 私有类属性

- 类属性也可以设置为 **私有**，前边添加两个下划线`__`

```python
class Dog(object):
    """狗类"""
    # 私有类属性
    __count = 0


# 注意：类私有属性在类外部不能通过`类名.类属性名`访问
# AttributeError: type object 'Dog' has no attribute '__count'
print(Dog.__count)
```

### 8.4 小结

1. 类属性的定义方式：定义在**类里面，类方法外面**的变量就是**类属性**

   - 类属性可以使用 **类名** 或 **实例对象** 访问，**推荐使用类名访问**

     ```python
     # 定义类
     class 类名(object):
         类属性 = 值1
     
         def __init__(self):
             pass
     ```

2. 类属性和实例属性的区别

   - **类属性属于类的，被该类所有实例对象所共有**
   - **实例属性只属于某个实例对象，实例属性只能通过实例对象名访问**

## 9. 类方法、静态方法

学习目标：

1. 知道实例方法、类方法、静态方法的区别

------

### 9.1 实例方法

**实例方法**：

- 属于实例对象的方法，第一个形参是**self**，**只能通过实例对象进行调用**，self形参就是实例对象
- **创建的每个对象的实例属性,它都不一样的时候,用实例方法**

示例代码：

```python
class Dog(object):
    """狗类"""
    def __init__(self, _name, _age):
        self.name = _name
        self.age = _age

    # 实例方法：只能通过实例对象进行调用
    def show_info(self):
        print(f'我的名字：{self.name}, 年龄：{self.age}')


print('======================= 示例1 =======================')
# 创建一个 Dog 对象
dog1 = Dog('小黄', 1)
dog1.show_info()
```

运行结果：

```python
======================= 示例1 =======================
我的名字：小黄, 年龄：1
```

### 9.2 类方法

**类方法**：

- 属于类对象(类)的方法，可以通过类名或实例对象名进行调用
- 作用：用于对一类事物进行操作，和具体的某个实例对象没有直接关联关系，若类中的方法方法在逻辑上采用 类本身来调用更合理，那么这个方法就可以定义为类方法
  - 需求：在类中提供一个方法，展示一共有多少只狗
- **简单来说:就是这个方法访问的属性跟具体的哪个对象没有关系,只是访问类里面类属性**

**类方法定义**：

```python
class 类名(object):
    @classmethod
    def 类方法名(cls):
        pass
```

**注意**：类方法必须有一个形参，一般叫 **cls**，调用类方法是 cls 形参不用传递，python解释器会自动传递

**类方法调用**：

- `类名.类方法(...)`【推荐使用】
- `对象名.类方法(...)`【不推荐使用】

示例代码：

```python
class Dog(object):
    # 类属性
    count = 0

    def __init__(self, _name, _age):
        # 实例属性
        self.name = _name
        self.age = _age

        # 只要__init__调用，就说明创建了一个对象，类属性 count 就加1
        Dog.count += 1

    # 实例方法：只能通过实例对象进行调用
    def show_info(self):
        print(f'我的名字：{self.name}, 年龄：{self.age}')

    # 需求：提供一个显示一共有多少只狗的方法
    @classmethod
    def show_dog_count(cls):
        # print('测试cls：', id(cls))
        print(f'现在一共有{cls.count}只狗')


print('======================= 示例2 =======================')

print('测试Dog：', id(Dog))
# 调用类方法
# 底层原理：Dog.show_dog_count() 等价于 show_dog_count(Dog)，python解释器自动将 Dog 传递给了 cls
Dog.show_dog_count()

# 创建 Dog 类的实例对象
dog1 = Dog('旺财', 1)
Dog.show_dog_count()

dog2 = Dog('小黑', 2)
Dog.show_dog_count()
```

运行结果：

```python
======================= 示例2 =======================
测试Dog： 2568311737840
现在一共有0只狗
现在一共有1只狗
现在一共有2只狗
```

**示例方法与类方法例子**

![image-20220815184141215](E:\黑马培训\Python进阶笔记\assets\image-20220815184141215.png)

### 9.3 静态方法

**静态方法**：

- 主要是用来存放逻辑性的代码，逻辑上属于类，但其实和类本身没有关系，也就是说在静态方法中， 不会涉及到类中的属性和方法的操作。
- 可以理解为，静态方法是个独立的、单纯的函数，它仅仅托管于某个类中，便于使用和维护。
- **类里面的属性和实例对象的方法等,什么数据,啥都用不到,只是理上属于这个类,放在这里面   比较合理**

**静态方法定义**：

```python
class 类名(object):
    @staticmethod
    def 静态方法名():
        pass
```

**静态方法调用**：

- `类名.静态方法(...)`【推荐使用】
- `对象名.静态方法(...)`【不推荐使用】

示例代码：

```python
class SysManager(object):
    """管理系统类"""
    # 需求：提供一个显示菜单的方法
    @staticmethod
    def show_menu():
        """显示菜单"""
        print('========================')
        print('= 1. 添加学生')
        print('= 2. 查询所有学生')
        print('= 3. 查询某个学生')
        print('= 4. 修改某个学生')
        print('= 5. ......')
        print('========================')


print('======================= 示例3 =======================')

# 调用静态方法：推荐使用【类名.静态方法名()】的形式进行调用
SysManager.show_menu()
```

运行结果：

```bash
======================= 示例3 =======================
========================
= 1. 添加学生
= 2. 查询所有学生
= 3. 查询某个学生
= 4. 修改某个学生
= 5. ......
========================
```

### 9.4 小结

1. 类方法、实例方法、静态方法的区别

   - 定义方法区别

     ```python
     class 类名(object):
         # 实例方法定义
         def 实例方法名(self):
             pass
     
         # 类方法
         @classmethod
         def 类方法名(cls):
             pass
     
         # 静态方法
         @staticmethod
         def 静态方法名():
             pass
     ```

   - 调用方法区别

     - 实例方法必须通过**实例对象名**调用
     - 类方法、静态方法可以通过 **实例对象** 和 **类名** 调用，推荐使用类名的方式调用
   
   **区别实例方法,类方法,静态方法**
   
   1. 实例方法:需要访问每个实例对象的数据
   2. 类方法,只需要访问类属性的数据,跟实例对象没有关系
   3. 静态方法,没有使用类里面的任何数据

## 10. 补充知识点

### 10.1 _ _ mro _ _ 魔法方法

**快速的查看类的继承关系**,从左到右,右边的是左边前一个的父类

## 10. 总结

**一、面向对象：继承、属性、方法**

**1.私有权限**

- 公有权限和私有权限的区别：
  - 在进行类的定义时，以  **开头的属性称为私有属性，以**  开头的方法称为私有方法
  - 私有属性：不能在类定义外部直接通过`对象.属性名`的形式访问，只能在类内部定义的方法中进行访问
  - 私有方法：不能在类定义外部直接通过`对象.方法名(...)`的形式调用，只能在类内部定义的方法中进行调用

**2.继承**

**2.1【记忆】继承介绍**

1. 继承的作用：解决代码重用问题，提高开发效率

2. 继承的语法格式：

   ```python
   class 子类名(父类名)：
       pass
   ```

**2.2【重点】单继承和多继承**

- 单继承：子类只继承一个父类

- 多继承特点：子类有多个父类

- 多继承语法格式：

  ```
  class 子类名(父类1, 父类2, ……)：
      pass
  ```

**2.3【重点】多层继承**

- 多层继承：类的继承具有多层传递的效果，如生活中的`爷爷、父亲、儿子`

**3.【记忆】重写父类方法**

1. 子类重写父类同名方法：在子类中定义了一个和父类同名的方法
2. 子类重复父类方法之后，调用父类同名方法：
   - `父类名.同名方法(self, 形参1, ……)`：调用指定的父类
   - `super(类名, self).同名方法(形参1, ……)`：调用类的继承顺序链上指定类的下一个类中的同名方法
   - `super().同名方法(形参1, ……)`：`super(当前类, self).同名方法(形参1, ……)`的简写

**4.【知道】私有和继承**

1. 父类的私有方法、属性不能直接被子类继承使用

**5.【了解】多态初理解**

1. 多种形态，同一个代码，由于传递的实例对象的不同，最终代码调用有不同的结果，这就叫多态

**6.【记忆】实例属性和类属性**

1. 类属性的定义方式：定义在**类里面，类方法外面**的变量就是**类属性**

   - 类属性可以使用 **类名** 或 **实例对象** 访问，**推荐使用类名访问**

     ```python
     # 定义类
     class 类名(object):
         类属性 = 值1
     
         def __init__(self):
             pass
     ```

2. 类属性和实例属性的区别

   - 类属性属于类的，被该类所有实例对象所共有
   - 实例属性只属于某个实例对象，实例属性只能通过实例对象名访问

**7. 【记忆】实例方法、类方法、静态方法**

类方法、实例方法、静态方法的区别

- 定义方法区别

  ```python
  class 类名(object):
      # 实例方法定义
      def 实例方法名(self):
          pass
  
      # 类方法
      @classmethod
      def 类方法名(cls):
          pass
  
      # 静态方法
      @staticmethod
      def 静态方法名():
          pass
  ```

- 调用方法区别

  - 实例方法必须通过**实例对象名**调用
  - 类方法、静态方法可以通过 **实例对象** 和 **类名** 调用，推荐使用类名的方式调用

## 面向对象day02-知识点总结

1）面向对象案例-搬家具【理解】

**目标：**

* 对昨天基础语法的回顾
  * 怎么定义类、怎么定义方法、怎么给对象添加属性、`__init__`和`__str__`魔法的使用、...
* 对面向对象编程步骤回顾
  * 分解对象
  * 抽象出类：分析类的对象的属性和方法
  * 定义出类
  * 创建对象，实现功能

2）私有属性和私有方法【理解】

**目标：**

* 公开权限：公开属性和公开方法，在类定义的外部，直接通过对象进行访问
  * 优点：便于访问
  * 缺点：随意设置，可能造成数据不合法...
* 私有权限：私有属性和私有方法，在类定义的外部，不能通过对象进行访问
  * 优点：增加了访问权限的控制
  * 缺点：不便于访问，而且相对来说代码比较多一点

> 注意：之后我们写python，几乎还是直接用公开的。

**3）继承的基础知识【重点】**

**目标**：

* 解决了什么问题？代码重用，提高开发效率。
* 继承的语法

```python
# 单继承：子类只继承了一个父类
class 子类名(父类名):
    pass

# 多继承：子类同时继承了多个父类（两个及以上）
class 子类名(父类1, 父类2, ...):
    pass

# 问题：子类继承的多个父类中有多个同名方法，`子类对象.同名方法(...)`调用哪个？
# 前提：子类并没有重写父类中的那个同名方法。
# 答：默认调用先继承的那个父类中的同名方法。
```

* 类的继承具有多层传递的效果
  * 类似于生活中代代相传

**4）子类重写父类中的方法【重点】**

* 重写的目的
  * 父类中的代码不满足或不完全满足子类的需要，子类为了扩展功能，可以对父类的方法进行重写
* 重写的形式
  * 在子类中定义一个和父类同名的方法，就表示对父类方法进行重写。
* 重写的效果
  * 重写之后，通过`子类对象.同名方法(...)`调用的就是自己的，不再是父类的。

**子类重写之后调用父类中的同名方法**：

* 方式1：`父类名.同名方法(self, ...)`
  * 最容易理解，但是不灵活（父类名如果改了，代码还要改）
* 方式2：`super(指定类名, self).同名方法(...)`
  * 类的继承顺序链：指的就是一个类继承的先后顺序
    * `类名.__mro__`
  * 本质：调用`最开始那个类的继承顺序链`上，你指定的那个类的`下一个类`中的同名方法。
    * 注意：分析代码的时候，无论走到哪个类中，`一定要看最开始那个类的继承顺序链`。

* 方式3：`super().同名方法(...)`
  * 这是一种简写，完整写法：`super(当前类名, self).同名方法(...)`

**私有和继承【了解】**：

* 父类中的私有属性和私有方法子类不能直接继承，如果子类想使用，可以在父类中提供公开的方法达到间接访问的效果。

5）多态

* 同一行代码，由于传入的实例对象的不同，最终代码的调用产生了不同的效果，这就叫多态！！！

```python
# 以下这三种方式，都表示继承的是 object
class 类名(object):
	pass

class 类名:
    pass

class 类名():
    pass
```







