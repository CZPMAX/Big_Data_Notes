# 多任务编程

## 1. 进程与线程

**一个小困惑点： ** 线程的开启是按顺序开启还是同时间开启的？

**代码示例：**

```python
def dance():
    time.sleep(1)
    for i in range(10):

        print('我在跳舞...')


def sing():
    time.sleep(1)
    for i in range(10):
        print('我在唱歌...')


if __name__ == '__main__':
    # 创建线程
    a_process = threading.Thread(target=dance)
    b_process = threading.Thread(target=sing)

    # 开启线程
    a_process.start()
    b_process.start()

```

**解释说明：**   主线程按代码顺序开启一线程，如果没有一线程没有阻塞的话，正常就是一线程跑完了以后，二线程开启。但是如果一线程中的代码有sleep，让一线程睡眠了以后，一线程就会失去对Cpu的控制权，这时候主线程拿过了Cpu的执行权，这样一来，主线程就去把二线程给开启，就这样会有会有两个子线程在就绪状态，而且另一个线程里也有睡的代码,这样一来就会有两个线程在cpu里面抢夺控制权，这样就出现了交替打印的情况。

**一句话只要正在使用CPU的线程sleep了，就是处于阻塞状态，这时候这个线程就失去了cpu的执行权**

**主进程控制子进程的创建,但是不同时创建,按照代码执行顺序.创建子进程,子进程会把主进程的东西都复制一份,等待这个进程结束后,按照代码执行顺序又会创建下一个子进程,等待着子进程全部执行完毕以后,主进程才会结束**

**主线程中开启了一个子线程，开启之后，主线程与子线程互不影响各自的[生命周期](https://so.csdn.net/so/search?q=生命周期&spm=1001.2101.3001.7020)，即主线程结束，子线程还可以继续执行；子线程介素，主线程也能继续执行**。**而主线程结束时一般都等待着所有的子线程结束它才会结束**

**多线程就是在一个进程里面包含多个线程,主线程负责创建子线程,进程负责分配资源,进程负责干活,主线程负责main里面的代码**

**进程与线程之间的关系图解:**

![image-20220822191028923](E:\黑马培训\Python进阶笔记\assets\image-20220822191028923.png)

python里面进程中的线程只能一个一个跑

python多线程一次只能运行一个线程

让主线程睡眠了以后,相当于主线程停止了,只有唤醒了,主线程才会接着运行,运行到主线程的最后一句代码程序结束,如果子线程是守护进程,只要主线程一停,无论是睡一会还是直接停,看见主线程不做了,子线程马上停止

按照操作系统理论严格来说,多线程并不是多个线程一起运行的.
因为多线程实际上是多个线程之间轮流执行的,就是将一个时间段分成若干个时间片,每个线程只运行一个时间片,由于时间片极短,而且电脑运行极快,线程之间切换也极快,几乎可以看做是并行运行的,也就是说可以看成是同时运行的.但实际却不是的同时运行的

这里使用了join()方法，让主线程等待子线程结束，然后主线程继续执行。这里join()方法必须要在子线程启动之后，再调用。
**进程是资源分配的基本单位，线程是cpu调度的基本单位**。对于cpu来说，其实不存在主线程和子线程之分，都是一个线程。进程的资源是进程下面的线程所共享的，只要进程还在，线程就可以正常执行，也就是说线程是依赖于进程的，线程与线程之间并不存在依赖关系，一个线程的死亡理论上不会对其他线程造成影响。但是上面通过调用JVM提供的接口，例如setDaemon与join改变了主线程与子线程的关系，这些应该是JVM接口代码做了处理干扰了线程的生命周期。
守护线程与非守护线程本质上没什么区别，但是如果虚拟机中存活的线程都是守护线程的时候，虚拟机就会退出，只要虚拟机中还有一个非守护线程，虚拟机就不会退出。

**示例代码:**

![image-20220822190923745](E:\黑马培训\Python进阶笔记\assets\image-20220822190923745.png)

在这里如上图所示有两种方法:  可以让在主进程停止时子进程也停止: 1. 设置守护进程(左图)  2. 强制终止子进程(右图)

**有趣解释:**

![image-20220822203933843](E:\黑马培训\Python进阶笔记\assets\image-20220822203933843.png)

左图具体理解: 主进程开启子进程后,当主进程睡眠了,不运行了,子进程因为是守护进程,它看到主进程消失了,自己没尽到守护的责任也自尽了,这时候主进程醒来了,打印完print语句,代码全部执行完毕自己也结束了.  如果没有把子进程设置为守护进程,那么我们主线程睡眠时,子进程还是会继续自己在执行自己的,这时候结束的条件就是开启进程的那个函数什么时候执行完,什么时候结束.  然后在输出语句中,我们还能看见中间有穿插着一句话,主进程结束

**没有守护子进程和强制执行结束时的结果:**

![image-20220822201717743](E:\黑马培训\Python进阶笔记\assets\image-20220822201717743.png)



右图具体理解: 前面的解释还是和上面一样,print是属于主进程的代码,主进程没有醒来它不会执行,而下面的子进程调terminate这个函数,因为在子线程创立之初,他们都已经有了各自的生命周期,互不影响,而这句代码是属于子进程的,    所以在主进程睡眠以后,子进程本来还想继续自己执行下去的时候,碰到了这个函数,一执行把自己强制关闭了,这时候子进程结束了,当主进程从睡眠中醒来,打印完最后一句print语句后,自己也彻底结束了

**运行结果:**

![image-20220822201828122](E:\黑马培训\Python进阶笔记\assets\image-20220822201828122.png)

**进程创建图解:**

![image-20220822192920733](E:\黑马培训\Python进阶笔记\assets\image-20220822192920733.png)

**在一个进程内多个线程抢占资源图解:**

![image-20220822192621193](E:\黑马培训\Python进阶笔记\assets\image-20220822192621193.png)

**注意点:**

![image-20220822203047668](E:\黑马培训\Python进阶笔记\assets\image-20220822203047668.png)

**一个进程内创建了多个线程,主线程控制了子线程的创建   图解**

![image-20220822203151674](E:\黑马培训\Python进阶笔记\assets\image-20220822203151674.png)

**进程与线程实现多任务的图示:**

![image-20220822203245336](E:\黑马培训\Python进阶笔记\assets\image-20220822203245336.png)

**进程在计算机底层的运行原理:**

![image-20220822203332484](E:\黑马培训\Python进阶笔记\assets\image-20220822203332484.png)

**进程与线程的对比:**![image-20220822203423225](E:\黑马培训\Python进阶笔记\assets\image-20220822203423225.png)

互斥锁来防止线程共同访问一个资源会出的问题 还有一种方式便是子线程开启后,紧接着去调用jn函数

进程就是用来运行函数的

锁的范围越小花销的时间越大,锁的力度人为可以控制

**同一个进程内的多个线程会共享全局变量，当多个线程同时操作同一个共享的全局变量时，可能会造成错误的结果！**

创建线程和创建进程所导入的包不同 创建线程要导入的模块时Threading  默认在python.exe这个进程下创建线程,进程为线程分配资源,线程去具体的干活 (线程存在的前提就是在进程下)   创建进程导入的模块则是multiprocessing

循环创建，每次创建的线程实质上它都不一样，不是同一个东西，线程号也是从1 ~ n 依次递增的 

**进程之间不共享全局变量**

```python
"""
进程使用的注意点：
学习目标：知道进程使用的 2 个注意点
"""

"""
进程使用的注意点介绍：
1）进程之间不共享全局变量
2）主进程会等待所有的子进程执行结束再结束
"""

# 注意点1：进程之间不共享全局变量
import multiprocessing
import time

# 定义全局变量
g_list = []


# 添加数据的函数
def add_data():
    for i in range(5):
        g_list.append(i)
        print('add：', i)
        time.sleep(0.2)

    print('add_data：', g_list)


# 读取数据的函数
def read_data():
    print('read_data：', g_list)


if __name__ == '__main__':
    # 创建添加数据的子进程
    add_data_process = multiprocessing.Process(target=add_data)
    # 创建读取数据的子进程
    read_data_process = multiprocessing.Process(target=read_data)

    # 启动添加数据子进程
    add_data_process.start()
    # 主进程等待 add_data_process 执行完成，再向下继续执行
    add_data_process.join()
    # 启动读取数据子进程
    read_data_process.start()

    print('main：', g_list)
```

**线程之间共享全局变量：**

```python
import threading
import time

# 定义全局变量
g_list = []


# 添加数据的函数
def add_data():
    for i in range(5):
        g_list.append(i)
        print('add：', i)
        time.sleep(0.2)

    print('add_data：', g_list)


# 读取数据的函数
def read_data():
    print('read_data：', g_list)


if __name__ == '__main__':
    # 创建添加数据的子线程
    add_data_thread = threading.Thread(target=add_data)
    # 创建读取数据的子线程
    read_data_thread = threading.Thread(target=read_data)

    # 启动添加数据子线程
    add_data_thread.start()
    # 主线程等待 add_data_thread 执行完成，再向下继续执行
    add_data_thread.join()
    # 启动读取数据子线程
    read_data_thread.start()

    print('main：', g_list)

```

## 2. 进程中，线程中的抢资源

**关于sleep**

如果需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用 time 模块的 sleep(secs) 函数来实现。该函数可指定一个 secs 参数，用于指定线程阻塞多少秒。当前线程调用 sleep() 函数进入阻塞状态后，在其睡眠时间段内，该线程不会获得执行的机会，即使系统中没有其他可执行的线程，处于 sleep() 中的线程也不会执行，因此 sleep() 函数常用来暂停程序的运行。

**线程抢资源代码示例与分析：**

**代码1  sleep放在上面：**

```python
import threading
import time 

def task():
    time.sleep(1)
	print(f'当前进程: {threading.current_thread().name}')
    
if __name__ == 'main':
	for i in range(5):
        task_thread = threading.Thread(target=task)
        task_thread.start()
```

**运行结果分析**     线程在抢资源执行   打印出来结果每次都不一样  线程由被创建的时间 依次被分为 Thread(1) ~ Thread(n)

**原因：** 首先明确用for循环来创建线程，线程是一个个放出来的，当第一个线程被放出来后,线程开始跑，执行task函数，一进来函数就执行到sleep函数，然后这个线程就进入了阻塞状态，在这段时间内这个线程不会获得cpu的执行权，就把执行权释放了，这时候在内存中的其他线程会过来拿执行权，注意这时候因为刚开始就只有主线程和子线程各一个，总共两个线程，所以过来接收执行权的人是主线程，又因为子线程的创建是受主线程控制的，所以主线程会接着创建下一个线程，因为只创建5个子线程，休眠时间设为了一秒，这对计算机来说是很长的时间，而程序跑的很快所以差不多会有5个线程被堵在这里，而唤醒的时间又不一样，所以会出现抢资源和并发的情况。

**代码2 sleep放在下面：**

```python
import threading
import time 

def task():
    
	print(f'当前进程: {threading.current_thread().name}')
    time.sleep(1)
    
if __name__ == 'main':
	for i in range(5):
        task_thread = threading.Thread(target=task)
        task_thread.start()
```

**运行结果分析**  没有抢资源执行 按顺序执行

**原因：**放在下面的话，本身起步就只有一个线程在执行，线程在跑函数，当函数打印完自己的线程号，就sleep了然后线程进入阻塞状态，这时候释放对cpu的执行权，在内存中的其他线程，即主线程就拿到了线程的执行权，就开始了创建下一个子线程，如此往复，这样就按顺序堆积了5个线程，如果下面没有其他的代码再供函数运行，那么线程就依次结束了，如果再来一个print的话，也就是会像上面一样抢资源输出

## 3. 线程资源共享问题

利用join 或者 互斥锁解决  

互斥锁的创建相当于一个全局变量

lock = Threading.Lock() 这就是相当于创建了一把互斥锁

互斥锁实现原理图：

![image-20220822225721509](E:\黑马培训\Python进阶笔记\assets\image-20220822225721509.png)

**注意:**  在这里面想要操作全局变量必须先拿到互斥锁,没有锁就操作不了变量,这时候在在执行子线程1的三步操作时,也有可能到赋值的那一刻,被切到去运行子线程2,但是2手上还是没有锁,所以操作不了全局变量,只能等待,接着主线程还是得切到线程1去让他执行完来释放锁



**注意:** 互斥锁可以保证线程代码同时执行的前提下解决资源共享问题，但是加锁、释放锁会浪费一下时间！！！



**代码：**

```python

线程等待(join)：等待一个线程执行结束之后，代码再继续执行，同一时刻只有一个线程执行
import threading

# 定义全局变量
g_num = 0


def sum_num1():
    global g_num
    # 循环一次给全局变量加1
    for i in range(1000000):
        g_num += 1

    print('sum1：', g_num)


def sum_num2():
    global g_num
    # 循环一次给全局变量加1
    for i in range(1000000):
        g_num += 1

    print('sum2：', g_num)


if __name__ == '__main__':
    # 创建两个线程
    first_thread = threading.Thread(target=sum_num1)
    second_thread = threading.Thread(target=sum_num2)

    # 启动两个线程
    first_thread.start()
    # 让主线程等待 first_thread 线程执行结束，在向下执行，启动 second_thread
    first_thread.join()
    second_thread.start()

    
    
    
    
# 注意：如果通过上面的方式资源共享问题，其实和单线程效果是一样的，程序并没有同时执行

# 互斥锁：多个线程去抢同一把"锁"，抢到锁的线程执行，没抢到锁的线程会阻塞等待
import threading

# 定义全局变量
g_num = 0

# 创建一个互斥锁
lock = threading.Lock()


def sum_num1():
    global g_num
    # 循环一次给全局变量加1
    for i in range(1000000):
        # 尝试抢锁：抢到锁代码可以继续执行，否则阻塞等待
        lock.acquire()
        g_num += 1
        # 释放锁
        lock.release()

    print('sum1：', g_num)


def sum_num2():
    global g_num
    # 循环一次给全局变量加1
    for i in range(1000000):
        # 尝试抢锁：抢到锁代码可以继续执行，否则阻塞等待
        lock.acquire()
        g_num += 1
        # 释放锁
        lock.release()

    print('sum2：', g_num)


if __name__ == '__main__':
    # 创建两个线程
    first_thread = threading.Thread(target=sum_num1)
    second_thread = threading.Thread(target=sum_num2)

    # 启动两个线程
    first_thread.start()
    second_thread.start()


```

**进程与线程说白了是来执行多任务,导入相应的模块,接着写具体要实现的函数,在主进程或者主线程里面创建子进程或者子线程去跑函数**

## 4. 为什么在进程中一定要使用if  __ name __ == ‘__ main __':

首先讲为什么Windows系统中使用多进程不加if name == 'main’会报错，这主要是因为python创建子进程的时候相当于会开辟新的一块内存空间去存储主进程中的代码，并且是通过导包的形式去复刻主进程中的代码的，那么这里就会有一个问题，如果不加if name == 'main’这个判断的话，那么执行代码的时候就会无限递归的创建子进程，但是multiprocessing.Process的源码中对无限递归的创建子进程这种行为是不允许的，所以就出现了报错提示，因此在windows系统中执行上面代码的时候就需要将创建子进程的代码放在if name == ‘main’ 这个判断下，这个时候子进程中通过导包的形式复刻的代码里面if name == 'main’这个判断会不成立，因为此时的 name 就不是 'main’了，在子进程中下面的代码也就不会被执行，那么最后也就不会报错了。

![image-20220822232709162](E:\黑马培训\Python进阶笔记\assets\image-20220822232709162.png)

## 5. 正则表达式

*号匹配完还会向后尝试匹配,如果没匹配成功则返回空匹配结果一个个往后,到匹配到空则返回空,正则匹配结束

用+号的时候匹配到一个则返回一个结果,接下来没匹配到的话则不返回结果  如下图所示:

![image-20220822192809049](E:\黑马培训\Python进阶笔记\assets\image-20220822192809049.png)



**正则的语法 第一个图片写在前,第二个图片写在后**

![image-20220822203831128](E:\黑马培训\Python进阶笔记\assets\image-20220822203831128.png)

![image-20220822203840395](E:\黑马培训\Python进阶笔记\assets\image-20220822203840395.png)

p?y 表示?号前面的p可有可无

\d{2} 表示匹配连续的两个数字 即两位上的数都相同

*的意思我这个正则能匹配多个也能什么没匹配,如果没匹配到则返回空

# Python进阶-day07总结

**1）多任务的基本概念【理解】**

* 多任务概念：多个任务同时执行，可以充分利用CPU的资源，提高程序的执行效率。
* 多任务实现：多进程实现多任务 vs 多线程实现多任务
  * **多进程实现多任务：通过创建进程，让每个进程内的默认的一个线程工作**
  * **多线程实现多任务：同一个进程，创建多个线程，让每个线程工作**
* 多任务执行：
  * 并发：通过一个 CPU 核心快速交替执行多个任务，让用户感觉是"多任务"
  * 并行：每个 CPU 核心执行一个任务，真正的多个任务同时执行
  * 注意：在实际的电脑中，程序的运行往往既会有并发，也会有并行，**至于我们的程序运行之后，是以并发的形式执行，还是以并行的形式执行，是CPU控制的，我们干预不了**。

2）多进程实现多任务

* 进程：**进程是操作系统进行资源分配的基本单位**。（创建进程时，操作系统为给创建的进程分配资源，比如：内存）

* python中进程的使用
  * 模块：mutilporcessing
  * 参考课堂代码
* 进程使用的注意点
  * 进程之间不共享全局变量（因为创建子进程时，子进程会把主进程的东西复制一份）
  * 主进程默认会等待它所有的子进程结束再结束
    * 守护进程的设置：皇帝（主进程）死了，臣子（子进程）不再苟活
    * 强制终止子进程：君要臣死，臣不得不死

3）多线程实现多任务

* 线程：**线程是CPU调度的基本单位**。(进程相当于是一家公司，只负责提供资源，线程相当于员工，负责真正的干活)
* python线程的使用
  * 模块：threading
  * 参考课堂代码
* 线程使用的注意点
  * 同一个进程内的线程的执行是没有顺序
  * 主线程默认会等待所有的子线程结束再结束
    * 守护线程的设置

  * 同一个进程内多个线程共享全局变量
    * 问题：线程的资源共享问题（同一个进程内的多个线程同时操作一个共享资源，会产生资源竞争）
    * 解决
      * 线程等待：强制让一个线程先执行结束，然后再去执行另一个线程
        * 这种方式，其实和单任务没有区别了

      * 互斥锁：任何线程要想操作共享资源，先要拿到互斥锁，拿到锁的线程可以操作共享资源，操作完成之后需要把锁释放；拿不到锁的线程必须等待，直到抢到锁才能执行。
        * 这种方式，保证多任务的同时执行，但是加锁、释放锁会有时间开销，可以通过代码控制锁的粒度（锁的范围）


* 进程和线程对比

  * **关系对比**：

    1. 线程是依附在进程里面的，没有进程就没有线程
    2. 一个进程默认提供一条线程，进程可以创建多个线程

  * **区别对比**：

    1. **进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位**
    2. 线程不能够独立执行，必须依存在进程中
    3. 创建进程的资源开销要比创建线程的资源开销要大
    4. 进程之间不共享全局变量，线程之间共享全局变量，但是要注意资源竞争的问题
    5. 多进程开发比单进程多线程开发稳定性要强

  * **优缺点对比**：

    进程优缺点：

    - 优点：可以用多核
    - 缺点：资源开销大
    - 场景：适合 计算型任务（比较耗CPU）

    线程优缺点:

    - 优点：资源开销小
    - 缺点：不能使用多核（**仅针对Python语言：GIL全局解释器锁**）
    - 场景：适合 IO密集型任务（IO：文件读写、网络请求，因为程序进行IO的时候，会把全局解释器锁释放）

2）正则表达式语法【常握】

* 作用：进行字符串的匹配、提取、替换...
* 语法
  * 匹配单个字符的符号
    * `.`，`\d`，`\D`，`\s`，`\S`，`\w`，`\W`，`[]`
  * 匹配多个字符的符号：需要和匹配单个字符的符号一起用
    * 匹配连续的多个字符
    * `*`，`+`，`?`，`{m}`，`{m,n}`
  * 其他
    * 匹配开头、结尾：`^`，`$`
    * 其他：`[^指定字符]`，`正则1|正则2`



# 概念题

### 1. 简述什么是并发？什么是并行？

**答案:**

并发:任务数量大于CPU核心数,在短时间内CPU快速切换执行多个任务
并行:任务数量小于等于CPU的核心数,多个CPU核心在短时间内共同执行多个任务



### 2. 说一下什么是进程？什么是线程？以及两者的区别？	

**答案:**

进程是程序的一次运行过程，进程可以看成程序执行的一个实例，进程是系统进行资源分配和调度的一个独立单位。

线程是进程的一个实体，是进程的一条执行路径，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位

区别对比：

1. 进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位
2. 线程不能够独立执行，必须依存在进程中
3. 创建进程的资源开销要比创建线程的资源开销要大
4. 进程之间不共享全局变量，线程之间共享全局变量，但是要注意资源竞争的问题
5. 多进程开发比单进程多线程开发稳定性要强

关系对比：

1. 线程是依附在进程里面的，没有进程就没有线程
2. 一个进程默认提供一条线程，进程可以创建多个线程



### 3. 什么是互斥锁? 说出互斥锁的应用场景

**答案:**

互斥锁: 为保证共享数据操作的完整性, threading模块给我们提供了一个Lock类, 我们把这个类创建的对象对应于一个可称为"互斥锁" 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该共享数据.

互斥锁应用场景: 互斥锁可用于多线程中有可能产生共享数据(如全局变量)竞争的场景.

### 4. 正则表达式有什么作用？

**答案**：

正则表达式：字符串匹配的一种模式，可以用来进行字符串的匹配、提取、替换等操作。

比如：

* 数据验证、数据提取、数据隐藏等









