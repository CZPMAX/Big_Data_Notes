# Zookeeper -- 分布式应用程序协调服务软件

## 1. ZooKeeper概述

**Zookeeper**是一个$\textcolor{red}{分布式协调服务的开源框架} $。主要用来解决分布式集群中应用系统的一致性问题。

![image-20220912203748798](E:\黑马培训\Hadoop生态圈\assets\image-20220912203748798.png)

![image-20220912202425031](E:\黑马培训\Hadoop生态圈\assets\image-20220912202425031.png)

ZooKeeper本质上是一个**分布式的小文件存储系统**。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效

管理。从而用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。

![image-20220912202446477](E:\黑马培训\Hadoop生态圈\assets\image-20220912202446477.png)

## 2. ZooKeeper特性

**全局数据一致**：集群中每个服务器保存一份相同的数据副本，client无论连接到哪个服务器，展示的数据都是一致的，这是最重要的特征；

![image-20220912203653345](E:\黑马培训\Hadoop生态圈\assets\image-20220912203653345.png)

**图解示意图:**

![4、zk的全局数据一致性](E:\黑马培训\Hadoop生态圈\assets\4、zk的全局数据一致性.png)

可靠性：如果消息被其中一台服务器接受，那么将被所有的服务器接受。

顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。

数据更新原子性：一次数据更新要么成功（半数以上节点成功），要么失败，不存在中间状态；

实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。

**附加:**

**zk如何保持全局数据一致性?**   

在发生写操作(就是事务性操作)的时候,会发生事务操作,来保证一个操作能同时成功或者同时失败,只有对内容有修改时才会用到事务,zk的

全局数据一执性主要是让leader主节点来进行调控的,它接收各个服务器的请求,对所有的事务性请求时间编号:  事务编号,根据编号依次执

行  具体: 把命令分发到各个从节点进行具体的操作

> ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



**全局数据一致性**

zk集群中每一个服务器保存一份相同的数据副本,客户端无论连接到哪里,展示的数据都是一样的,这是最重要的特征

> ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



**zk是标准的主从架构集群**

从角色follower处理客户端非事务请求(读请求),转发事务请求给leader,参与集群的leader投票

zk中除了leader与follower以外,它还有一个observer,观察者角色是大集群的环境下设置加入的,通常用于不影响集群事务处理能力的前提

下提升集群的非事务处理能力.对非事务请求可以进行独立处理,对于事务请求,则是会转发给leader进行处理,但是它不会参与任何形式的投

票只提供非事务服务.

> ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



## 3. ZooKeeper集群角色

![image-20220912202825672](E:\黑马培训\Hadoop生态圈\assets\image-20220912202825672.png)

**Leader:** 

Zookeeper集群工作的核心

事务请求（写操作）的唯一调度和处理者，保证集群事务处理的顺序性；

集群内部各个服务器的调度者。

*对于create，setData，delete等有写操作的请求，则需要统一转发给leader处理，leader需要决定编号、执行操作，这个过程称为一个事务。*

**Follower:**

处理客户端非事务（读操作）请求，转发事务请求给Leader；

参与集群Leader选举投票。

此外，针对访问量比较大的zookeeper集群，还可新增观察者角色。

**Observer:**

观察者角色，观察Zookeeper集群的最新状态变化并将这些状态同步过来，其对于非事务请求可以进行独立处理，对于事务请求，则会转

发给Leader服务器进行处理。不会参与任何形式的投票只提供非事务服务，通常用于在不影响集群事务处理能力的前提下提升集群的非事

务处理能力。

> Zookeeper主要是用来解决分布式应用中常遇到的一些数据管理问题,如**状态同步**,**集群选举管理**,**分布式应用配置项的管理**等

## 4. Zookeeper数据模型

**概述**

- 在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用树形层次结构；
- ZooKeeper树中的每个节点被称为：Znode，没有文件和目录之分；
- Znode兼具文件和目录两种特点；
- Znode存储数据大小有限制，通常以KB为大小单位；
- Znode通过路径引用，路径必须是绝对的，因此zk路径必须由斜杠字符/来开头，且路径唯一。

![image-20220912205207167](E:\黑马培训\Hadoop生态圈\assets\image-20220912205207167.png)



## **5. Znode详解**

![5、znode的节点种类--4类](E:\黑马培训\Hadoop生态圈\assets\5、znode的节点种类--4类.png)

- zk数据模型树中的每个节点称为一个znode，兼具目录文件两种特点。

- 每个znode由3部分组成:

  ① stat：此为状态信息, 描述该Znode的版本, 权限等信息

  ② data：与该Znode关联的数据

  ③ children：该Znode下的子节点

**znode stat状态信息**

**dataVersion：**数据版本号，每次对节点进行set操作，dataVersion的值都会增加1（即使设置的是相同的数据）即数字每改动一次这个值加1。

**cversion ：**子节点的版本号。当znode的子节点有变化时，cversion 的值就会增加1。

**cZxid ：** znode创建的事务id。

**mZxid ：** znode被修改的事务id，即每次对znode的修改都会更新mZxid。

对于zk来说，每次的变化都会产生一个唯一的事务id，**zxid**（ZooKeeper Transaction Id）。通过zxid，可以确定更新操作的先后顺序。

例如，如果zxid1小于zxid2，说明zxid1操作先于zxid2发生，**zxid对于整个zk都是唯一的**。

![image-20220912205525170](E:\黑马培训\Hadoop生态圈\assets\image-20220912205525170.png)

**ctime：**节点创建时的时间戳。

**mtime：**节点最新一次更新发生时的时间戳。

**ephemeralOwner：**如果该节点为临时节点, ephemeralOwner值表示与该节点绑定的session id。如果不是, ephemeralOwner值为0。

在client和server通信之前,首先需要建立连接,该连接称为session。连接建立后,如果发生连接超时、授权失败,或者显式关闭连接,连接便处于CLOSED状态, 此时session结束。

![image-20220912205711944](E:\黑马培训\Hadoop生态圈\assets\image-20220912205711944.png)



**Znode类型**

- 永久非序列化节点（PERSISTENCE）
- 临时非序列化节点（EPHEMERAL）
- 永久节点序列化（PERSISTENCE_SEQUENTIAL）
- 临时节点序列化（EPHEMERAL_SEQUENTIAL）



**临时、永久区别：创建的znode生命周期是否和创建其客户端的session状态有关？**

```
如客户端session结束，znode被自动删除-----> 临时节点（ephemeral node）

如客户端session结束，znode依然存在，除非手动强制删除-----> 永久节点（persistence node）
```

> 临时节点不允许拥有子节点。



- 序列化特性

开启序列化之后，会自动追加一个不断增加的序列号，记录每个子节点创建的先后顺序。

序列号对于此节点的父节点来说是唯一的，由10位数字组成。

![image-20220912210000623](E:\黑马培训\Hadoop生态圈\assets\image-20220912210000623.png)



## **6. Zookeeper的shell命令行操作(CURD)**

![6、zk shell创建节点参数意思](E:\黑马培训\Hadoop生态圈\assets\6、zk shell创建节点参数意思.png)

- 一键启动Zookeeper集群

  ```shell
  # 启动zk集群
  sh startZk.sh
  
  # 关闭zk集群
  sh stopZk.sh
  ```

  

- zk的操作 : 自带shell客户端

  ```shell
  /export/servers/zookeeper-3.4.6/bin/zkCli.sh -server ip
  # 例子: /export/servers/zookeeper-3.4.6/bin/zkCli.sh -server hadoop201
  # ip是自己指定的
  # 如果不加-server 参数 默认去连接本机的zk服务 localhost:2181
  # 如果指定-server 参数 就去连接指定机器上的zk服务
  
  # 退出客户端端 ctrl+c
  ```

  **附加小知识:**

  在zookeeper的一台机器上启动两台客户端,一台连接自己的本机,一台连接hadoop201,在不同的客户端上面,不管我们连接哪一台的

  zookeeper的机器,查看的数据都会是一致的,因为全局数据一致性的保证

  **在启动zookeeper后,在命令行中敲help  就会输出zk shell提示**

  **基本操作**

  - **创建节点**

    **create   [-s]   [-e]   path   data   acl**

    其中，-s或-e分别指定节点特性，顺序或临时节点，若不指定，则表示持久节点；acl用来进行权限控制

    **每台机子上都有文件目录树,根目录下默认有一个zookeeper节点**

    **创建永久节点:**

    

    ![image-20220913000525177](E:\黑马培训\Hadoop生态圈\assets\image-20220913000525177.png)

    **创建临时节点:**

    

    ![image-20220913003626747](E:\黑马培训\Hadoop生态圈\assets\image-20220913003626747.png)

    > 临时节点服务器一断开连接,他会让你重试,要是还是检测不到心跳信号,那就是真没了 ===>  客户端session结束，znode被自
    >
    > 动删除

    > 在哪台机器上创建临时节点,就要在哪台机子上断开客户端连接,这样才会把临时节点删除,如果在a机器上创建临时节点,在b机器上断开连接,那么临时节点不会被删除

    **创建顺序节点:**

    

    ![image-20220913002743179](E:\黑马培训\Hadoop生态圈\assets\image-20220913002743179.png)

  ​    **序列化节点允许重名,而非序列化不允许**

  

  ​                                      ![image-20220913003140306](E:\黑马培训\Hadoop生态圈\assets\image-20220913003140306.png)   

  

  >  因为在根目录下创建itcast节点时没有指定是序列化的节点,所以是非序列化的,当根目录下即要创建文件的位置下存在它的时
  >
  >  候,zk会报错节点已经存在

  ​       

  - **读取节点**

    与读取相关的命令有ls 命令和get 命令，ls命令可以列出Zookeeper指定节点下的所有子节点，只能查看指定节点下的第一级的所

    有子节点；get命令可以获取Zookeeper指定节点的数据内容和属性信息。

    ​        ls path [watch]

    　　get path [watch]

    　　ls2 path [watch]

    ![image-20220913005408546](E:\黑马培训\Hadoop生态圈\assets\image-20220913005408546.png)

    ```shell
    [zk: node2(CONNECTED) 28] ls /itcast   #查看指定路径下有哪些节点
    [zk: node2(CONNECTED) 28] ls / # 查看根目录下有哪些节点
    [aaa0000000000, bbbb0000000002, aaa0000000001]
    [zk: node2(CONNECTED) 29] get /
    
    zookeeper   itcast
    [zk: node2(CONNECTED) 29] get /itcast  #获取znode的数据和stat属性信息
    1111
    cZxid = 0x200000003   #创建事务ID
    ctime = Fri May 21 16:20:37 CST 2021 #创建的时间
    mZxid = 0x200000003   #上次修改时事务ID
    mtime = Fri May 21 16:20:37 CST 2021  #上次修改的时间
    pZxid = 0x200000009
    cversion = 3
    dataVersion = 0  #数据版本号  只要有变化 就自动+1
    aclVersion = 0
    ephemeralOwner = 0x0   #如果为0 表示永久节点 如果是sessionID数字 表示临时节点
    dataLength = 4   #数据长度
    numChildren = 3  #子节点个数
    ```

  - **更新节点数据**

    **set path data [version]**

    data就是要更新的新内容，version表示数据版本

    ```
    set path data
    # 意思是把指定路径下的数据修改成 data 例子如下
    set /itcast 123456
    ```

    ![image-20220913002435498](E:\黑马培训\Hadoop生态圈\assets\image-20220913002435498.png)

    现在dataVersion已经变为2了，表示进行了更新,数值每加一表示数据

    更新一次

    

  - **删除节点**

    > 不管是永久节点还是临时节点都能手动删除

    delete path [version]

    若删除节点存在子节点，那么无法删除该节点，必须先删除子节点，再删除父节点

    Rmr path

    可以递归删除节点

    ```shell
      [zk: node2(CONNECTED) 43] ls /itcast
      [aaa0000000000, bbbb0000000002, aaa0000000001]
      [zk: node2(CONNECTED) 44] delete /itcast/bbbb0000000002
      [zk: node2(CONNECTED) 45] delete /itcast               
    Node not empty: /itcast
      [zk: node2(CONNECTED) 46] rmr /itcast  #递归删除
    ```

  ----

​              **quota**

​              setquota -n|-b val path 对节点增加限制。

​              n:表示子节点的最大个数

​              b:表示数据值的最大长度

​              val:子节点最大个数或数据值的最大长度

​              path:节点路径

![image-20220913005828512](E:\黑马培训\Hadoop生态圈\assets\image-20220913005828512.png)

​              listquota path 列出指定节点的quota

![image-20220913005842813](E:\黑马培训\Hadoop生态圈\assets\image-20220913005842813.png)

​              子节点个数为2,数据长度-1表示没限制

​              delquota [-n|-b] path 删除quota

​              **history : 列出命令历史**

![image-20220913010819647](E:\黑马培训\Hadoop生态圈\assets\image-20220913010819647.png)

​               redo：该命令可以重新执行指定命令编号的历史命令,命令编号可以通过history查看

## **7. Zookeeper的监听机制**

### 7.1 简介

- ZooKeeper提供了分布式数据发布/订阅功能，一个典型的发布/订阅模型系统定义了一种一对多的订阅关系，能让多个订阅者同时监

  听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。

- ZooKeeper中，引入了Watcher机制来实现这种分布式的通知功能。ZooKeeper允许客户端向服务端注册一个Watcher监听，当服务

  端的一些事件触发了这个Watcher，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能。

- 触发事件种类很多，如：**节点创建，节点删除，节点改变，子节点改变**等。

- 总的来说可以概括Watcher为以下三个过程：客户端向服务端注册Watcher、服务端事件发生触发Watcher、客户端回调Watcher得

  到触发事件情况

**原理流程**

![1、zk的监听机制](E:\黑马培训\Hadoop生态圈\assets\1、zk的监听机制.png)

### 7.2 Watch机制的特点

**1. 一次性触发** 

   事件发生触发监听，一个watcher event就会被发送到设置监听的客户端，这种效果是一次性的，后续再次发生同样的事件，不会再次触发。

**2. 事件封装**

ZooKeeper使用WatchedEvent对象来封装服务端事件并传递。

WatchedEvent包含了每一个事件的三个基本属性：

通知状态（keeperState），事件类型（EventType）和节点路径（path）

**3. event异步发送**  

watcher的通知事件从服务端发送到客户端是异步的。

**4. 先注册再触发**

Zookeeper中的watch机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。



**通知状态和事件类型**

同一个事件类型在不同的通知状态中代表的含义有所不同，下表列举了常见的通知状态和事件类型。

![image-20220913011733589](E:\黑马培训\Hadoop生态圈\assets\image-20220913011733589.png)

- 监听机制

  - 监听实现需要几步？

  ```shell
  #1、设置监听 
  
  #2、执行监听
  
  #3、事件发生，触发监听 通知给设置监听的   回调callback
  ```

  在zookeeper的一台机器上开启一台客户端,在客户端对zk集群的服务器进行操作的,对操作项设置监听,在另一台客户端上,对

  zookeeper集群上的节点数据进行修改,这时候在设置监听的那台客户端,就会接收到相应的消息

  

- zk中的监听是什么？

  - 谁监听谁？

    ```
    客户端监听zk服务
    ```

  - 监听什么事？

    ```
    监听zk上目录树znode的变化情况。 znode增加了 删除了 增加子节点了 不见了
    ```

  - zk中监听实现步骤

    ```shell
    #1、设置监听 然后zk服务执行监听
    ls path [watch]
    	没有watch 没有监听 就是查看目录下子节点个数
    	有watch  有监听  设置监听子节点是否有变化
    get path [watch]
    	监听节点数据是否变化
    	
    e.g: get /itheima  watch	
    #2、触发监听 
    set /itheima 2222  #修改了被监听的节点数据 触发监听
    
    #3、回调通知客户端
    WATCHER::
    
    WatchedEvent state:SyncConnected type:NodeDataChanged path:/itheima
    ```

  - zk的监听特性

    - ==先注册 再触发==

    - ==一次性的监听==

    - ==异步通知==

    - ==通知是使用event事件来封装的==

      ```
      state:SyncConnected type:NodeDataChanged path:/itheima
      
      type：发生了什么
      path:哪里发生的
      ```

  - - zk中监听类型

      - 连接状态事件监听  系统自动触发 用户如果不关心可以忽略不计
      - 上述所讲的是用户自定义监听 主要监听zk目录树的变化  这类监听必须先注册 再监听。

  - ==总结：zk的很多功能都是基于这个特殊文件系统而来的。==

    - ==特殊1：znode有临时的特性。==
    - ==特殊2：znode有序列化的特性。顺序==
    - ==特殊3：zk有监听机制 可以满足客户端去监听zk的变化。==
    - ==特殊4：在非序列化节点下，路径是唯一的。不能重名。==

​         **原理图示:**

![image-20220913012427214](E:\黑马培训\Hadoop生态圈\assets\image-20220913012427214.png)

​         **简单流程:**    ![image-20220913094306004](E:\黑马培训\Hadoop生态圈\assets\image-20220913094306004.png)



## 8. zk的经典应用场景

### 8.1 数据发布与订阅

> 别名: 分布式环境统一配置中心  支持实时动态更新
>
> 本质是集中存储数据     局部监控的能力

zk客户端去设置监听,是给zk的服务器端设置监听,因为在所有客户端产生的指令例如 ls / , get /等都是,zk客户端发送信息给服务器端,服务器端来接收指令,做出相应的反应

**简介:**

数据发布/订阅系统即所谓的配置中心，也就是发布者将数据发布到ZooKeeper的一个节点上，提供订阅者进行数据订阅，从而实现动态

更新数据的目的，实现配置信息的集中式管理和数据的动态更新。

ZooKeeper采用的是**推拉相结合的方式**：客户端向服务器注册自己需要关注的节点，一旦该节点的数据发生改变，那么服务端就会向相应

的客户端发送Watcher事件通知，客户端接收到消息通知后，需要主动到服务端获取最新的数据。

主要用到了：监听机制

**整个流程图解示意:**

![2、zk的典型应用之---数据发布和订阅](E:\黑马培训\Hadoop生态圈\assets\2、zk的典型应用之---数据发布和订阅.png)

> ----------------------------------------------------------------------------------------------------



### 8.2 为其他软件进行选举服务

在分布式环境下，不管是**主从架构集群**，还是**主备架构集群**，要求在服务的时候有且有一个正常的对外提供服务，我们称之为master。

当master出现故障之后，需要重新选举出的新的master。保证服务的连续可用性。zookeeper可以提供这样的功能服务。

> 主要用到了：znode唯一性、临时节点短暂性、监听机制。

要发生这种情况,主节点leader必须是 临时 非序列化的节点

**选举图示:**

![3、zk的典型应用之---为其他软件进行选举服务](E:\黑马培训\Hadoop生态圈\assets\3、zk的典型应用之---为其他软件进行选举服务.png)



> 这上面的三个灰色框框里面的,就是三个节点,为了方便理解,我们给他们起了主从的名字,在上面例子里面master是我们假定的主节点

在哪台机器上创建临时节点,就要在哪台机子上断开客户端连接,这样才会把临时节点删除,如果在a机器上创建临时节点,在b机器上断开连

接,那么临时节点不会被删除,在上面的例子来说,要在leader服务器上,创建本地客户端连接,然后在他上面创建临时节点,然后断开客户端连

接,这时候老大几秒后会消失,释放了资源,触发了监听,告诉小弟老大死了,小弟们去抢注节点,成功的就变成老大,失败的就是小弟,接着再给小

弟设置监听,如果新老大又挂了,就还会触发监听,通知小弟抢资源去.

### 8.3 分布式锁

**简介:**

**ZooKeeper通过数据节点表示一个锁**，例如/itcast/lock节点就可以定义一个锁，所有客户端都会调用create()接口，试图在/itcast下创建

lock子节点，但是ZooKeeper的强一致性会保证所有客户端最终只有一个客户创建成功。也就可以认为获得了锁，其它线程Watcher监听

子节点变化（等待释放锁，竞争获取资源）。

此外也可以通过znode的序列化特性，给创建znode的客户端自动编号，从而实现所谓的顺序锁的功能。

![image-20220913104243551](E:\黑马培训\Hadoop生态圈\assets\image-20220913104243551.png)

### 8.4 zk内部的选举机制

**1. 全新集群选举:**

> 第一次启动集群时,不是出现在集群已经启动,而leader挂掉了,这时候又要开始新的选举的情况

**图解示意:**

![image-20220913113405122](E:\黑马培训\Hadoop生态圈\assets\image-20220913113405122.png)

**原理解释:**

zookeeper集群的启动是一台机子一台机子的启动(即按照顺序启动集群)

1.当启动第一台机子node1的时候,因为每个人都是自私的,所以它起来之后就会给自己投上一票,此时其他机器都没有启动.它向外面发投票

情况的消息,没有人应答它,可是它的投票票数没有过半,投票不能结束,这台机器的状态就转换为等待观望状态

2.接着开启第二台机器node2,同样的他也是自私的,    一上来就会给自己投一票,然后广播把自己的投票情况发送出去,     这时候就一台机器

node1活着,这时候就要看myid的大小,myid越大的权重越大,这时候node1就只能给node2投票,这时候node2得到2票,又要去查看票数有没

有过半,没有过半转换为looking状态

3.接着开启第三台机器,无论开启node3,还是node4,node5,结果都一样,因为它的权重大,都会得到前面myid小的人的票,再加上自己投自己

的票,统计总的票数再去查看票数有没有过半,这里假如开启node3,按照上面原理推测,node3得票为3,过半,所以它被选举出来当做老大称为

leader

4.接着node4开启,也是自己给自己投上一票,然后广播发送消息即查看投票情况,看其他机器是给他投票还是他给别人投票,这时候消息发到

node3,node3应答告诉node4自己是leader,node4不信继续向其他机器发送消息,得到结果一致,自己就接受了,就成follower了,node5其他

的也一样

5.投票结束就选出来了

> ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



**2. 非全新集群选举**

> 集群已经启动但是leader在使用的时候挂掉了，这时要重新选举leader



**原理：**

**优中择优 (也就是去查找节点中数据版本最新的节点)**



**1. 逻辑时钟**

给每个节点附上一个值,正常情况下逻辑时钟的数值都一致,不一致的就是不正常的



**2. 数据版本（事物id）**

> 数据版本通过get 节点查看
>
> 筛选掉版本小的节点



前两个版本的方法找leader的话最新的数据版本要只有一个才行,一般状态下,数据版本都是一致的,也就是说只要节点健康的话,前两个方法

找leader是不可行的,只能选择第三个方法



**3. myid**

> 选择myid大的机子