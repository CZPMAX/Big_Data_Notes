## 世上无难事只怕有心人

### 1. 传递参数与参数类型

传参的顺序: **普通形参(位置形参)  元组不定长形参  缺省形参  字典不定长形参**

#### 1.1 传递参数的两种方式

![image-20220803143545697](E:\黑马培训\assets\image-20220803143545697.png)

**第一种：位置参数的具体示例：**

```python
def trapezoid_area(base_up, base_down, height):
	return 1 / 2 * (base_up + base_down) * height
```

**开始调用函数**

```python
trapezoid_area(1, 2, 3)
```

不难看出，填入的参数1，2，3分别对应着参数base_up,base_down,height  -------像这种传入参数的方式称为 **位置参数**

**第二种：关键词参数的具体示例**

```python
trapezoid_area(base_up=1, base_down=2, height=3 )
```

更直观地,在调用函数的时候,我们将每个参数名称后面赋予—个我们想要传入的值。这种以名称作为——对应的参数传入方式被称作是**关键词参数**
**综合案例：**

![image-20220803144855540](E:\黑马培训\assets\image-20220803144855540.png)

- 第一种： 函数参数按照关键词传入，因为是关键词参数，所以不需要关心定义函数时形参的位置，函数会正常运行
- 第二种： 函数参数反序输入，但是到了第三个却变成了位置参数，遗憾的是这种方式是错误的语法,因为如果按照位置来传入,最后—个应该是参数height的位置。但是前面height已经按照名称传入了值3,所以是冲突的。
- 第三种： 函数参数正序传入,前两个是以关键词的方式传入,最后—个以位置参数传入,这个函数是可以正常运行的;
- 第四种：函数参数正序传入,前两个是以位置的方式传入,最后—个以关键词参数传入,这个函数是可以正常运行的。

**函数形参的次序问题：**

同一函数中，多种数据类型形参需要注意次序：普通参数，元组不定长参数，缺省形参，字典不定长形参

**示例：**

![image-20220804104029703](E:\黑马培训\assets\image-20220804104029703.png ![image-20220804104216026](E:\黑马培训\assets\image-20220804104216026.png)  

![image-20220804104159162](E:\黑马培训\assets\image-20220804104159162.png)

**超级注意细节**

**函数定义完以后有多少个参数，调用时就得传多少个，否则会报错**

使用位置参数传递变量时，形参的值只跟实参相对应位置上的值有关，与实参的名称无关

例子;

```python
# 函数定义
def trapezoid_area(base_up, base_down, height):
	return 1 / 2 * (base_up + base_down) * height


# 函数调用
base_up = 1
base_down = 2
height = 3
trapezoid_area(height, base_down, base_up)
```

此时函数输出的结果是; 2.5    不用看实参名，就看实参位置所对应的形参位置就行，直接赋值

**第三种：缺省参数（默认参数）的具体示例**

默认参数是可选的，这意味着即使你上来不给它传入什么东西函数还是可以正常运行的

要设定一个**默认参数**，**在定义参数时给参数赋值就可以了**

![image-20220803151051733](E:\黑马培训\assets\image-20220803151051733.png)

然后调用函数直接这样就行：

```python
trapezoid_area(1, 2)
```

print的可选参数 sep(意为每个打印的结果以.分开)的默认值为‘ '空格,但是我们将其重新传入‘\n'也就是换行的意思,一句话说,也就是将每个打印的数以换行符号进行分割。

sep=''  修改的是在一句Print语句中输出结果,每个结果之间以什么分割

end='' 修改的是多个print语句的输出方式，print函数默认以\n结尾，所以每句print打印都会自动换行

**在定义时缺省形参一定要在普通参数右边**

**第四种：混合参数**

(既有位置参数，又有关键字参数)，则必须位置参数在前，关键字参数在后

这些参数都是对于实参而言的，关键字参数之间不存在先后顺序

**第五种：不定长参数**

**不定长参数**也叫**可变参数**，用于不确定调用的时候会传递多少个参数（不传参数也行的情况）,用于形参

1. **元组不定长形参**
2. **字典不定长形参**

**作用：**当调用函数时不确定参数个数时，可以使用不定长参数

**类型：**

1. 位置传参
2. 关键字传参

**格式：**

在参数名前面写上*，或者**

如果是* 则表示可以接收所有的位置参数，形成元组

如果是**则表示可以接收所有的关键字参数，形成字典

实参传参的时候如果传的是元组或者列表等 需要在前面加个*告诉python这是个元组不定长形参,如果传的是字典,就要加**告诉python这里传递的是字典不定长形参

**代码实例:**

```python
# 1.定义一个有参函数两个参数分别是 元组不定长形参,字典不定长形参
def get_sum(*args, **kwargs):
    # # 2.定义一个变量_sum用来接收求和的值
    # _sum = 0
    # # 3.循环遍历元组取出里面的每个数累加
    # for i in args:
    #     _sum += i
    # # 4.循环遍历字典利用值的形式取值
    # for j in kwargs.values():
    #     _sum += j
    # # 输出结果
    _sum = sum(args)
    for j in kwargs.values():
        _sum += j
    print(f'累加结果为: {_sum}')


# 调用函数并且传参
get_sum(*(1, 2, 3), **{'a': 4, 'b': 5, 'c': 6})
"""
列表与元组可以利用sum函数来直接求里面元素的和，而字典则不行
"""

```

**细节：**

1. 如果位置参数。一般用*args 表示
2. 如果是关键字参数，一般用**kwargs  kw:keyword 关键字的意思

**演示元组不定长形参(只能接收位置参数的*args形成元组)：**

```python
def　getSum3(a,b,c):
	return a + b + c
	
def getSum4(a,b,c,d)
	return a + b + c + d
	
# 我们发现，上述代码：形参列表是不同的，但是函数体高度相似，这时就可以用(不定长参数)优化，如下

def getSum(*args): # 你把这的args当做元组即可
	sum = 0
	for i in args:
		sum += i
	return sum	


# 调用getSum()函数
print(getSum())
print(getSum(10,20))  # 30
print(getSum(10,20,30))  # 60
print(getSum(33,11,5,66)) # 115 
print(getSum(33,11,5,66，age=18))  # *args 可变参数，能接收所有位置参数，形成元组，无法接收，关键词参数

```

**演示一种情况**

```python
def getSum(*args):  # 你把这的args当做元组即可
    # sum = 0
    # for i in args:
    #     sum += i
    # return sum
    print(args)


# 调用getSum()函数
print(getSum())
print(getSum(10, 20))  # 30
print(getSum(10, 20, 30))  # 60
print(getSum(33, 11, 5, 66))  # 115
print(getSum(33, 11, 5, 66))  # *args 可变参数，能接收所有位置参数，形成元组，无法接收，关键词参数
```

**它的结果是**

为什么会出现None呢？  原因就是调用的函数没有返回值所以是None，所以用print就会输出None,所以只要调用这个函数就先行

**演示字典不定长形参(只能接收关键词参数****kwargs)形成字典**

```python
def show(**kwargs): # 它只能接收关键字参数形成字典
	print(kype(kwargs)) # <class 'dict'>
	print(kwargs)
    
show(name='刘亦菲',age=18)
```

**混合既有*args 又有    **

**kwargs,位置参数必须在前，关键字参数在后面

```python
def func1 (*args, **kwargs):
	print(args,type(args))  # (10,20,30)<class 'tuple'>
	print(kwargs,type(kwargs)) # {'name':'高圆圆','age':35}  <class 'dict'>
	
	
func1(10,20,30,name='高圆圆',age=35)
print('-' * 31)
# 位置要对上
```

**所有位置参数都要在关键字参数前面** **！！！！！！**

*args是位置参数的，**kwargs是接收关键字参数，不冲突，所以在一个函数中，可以共存

**总结**

![image-20220803223210829](E:\黑马培训\assets\image-20220803223210829.png)



### 2. 成员运算符与身份运算符

成员运算符和身份运算符的关键词是 in 与 is。把 in 放在两个对象中间的含义是,测试前者是否存在于 in 后面的集合中，is 是比较两个变量是否是同一个变量，返回的类型是True 和 False

### 3. 数据结构

Python 有四种数据结构，分别是：列表，字典，元组，集合

每种数据结构都有自己的特点：

![image-20220803154547693](E:\黑马培训\assets\image-20220803154547693.png)

**字典的特征总结如下:**

1. 字典中数据必须是以键值对的形式出现的;
2. 逻辑上讲,键是不能重复的,而值可以重复;
3. 字典中的键(key)是不可变的,也就是无法修改的;而值(vaIue)是可变的,可修改的,可以是任何对象。

### 4. 推导式

推导式comprehensions(又称解析式)，是Python独有的一种特性。推导式是可以从一个数据序列构建另一个新的数据序列(一个有规律的列表或控制一个有规律列表)的结构体

**作用：**用来简化python代码的

共有三种推导：

1. 列表推导式
2. 集合推导式
3. 字典推导式
4. 元组推导式

**使用最多的是列表推导式**

**基本语法：**

变量名 = [计算表达式 for 变量 in 列表 for 变量 in 列表]

变量名 = [计算表达式 for 变量 in 列表 **if 条件**] 先判断if条件是否会成立



**前面表达式缺什么后面就写什么!!!!!!**

![image-20220803170344337](E:\黑马培训\assets\image-20220803170344337.png)

**前面的表达式代表着:   你最后想输出数据的格式**

**range() 函数有步长的概念 格式range(起步位置，中止位置，步长)  包左不包右边**

需求： 生成1 —— 10 的列表

```python
list = [i for i in range(1, 11)] # i 从range里面一一取出数字赋值给 i
print(list1)
print('_'*13)
```

需求：生成1 —— 10 之间的所有偶数列表  **这种方式需要掌握**

```python
list = [i for i in range(0, 11, 2)]
print(list)
```

**重点例子：**快速生成元素列表 例如：[(1, 2), (1, 1), (1, 3),(2, 1), (2, 2), (2, 3)]

```python
list = [(i, j) for i in range(1, 3) for j in range(1, 4)]
print(list)
```

**字典推导式**

例子： 键是数字，值是它的平方，例如：1-->1  2-->4 3--> 9 .......

```python
dict = {i : i ** 2 for i in range(1, 6)}
print(dict)
```

需求：类似于enumerate() 的拉链操作

```python
list1 = ['乔峰','虚竹','段誉']
list2 = ['阿朱','梦姑','王语嫣']
dict = {list1[i]:list2[i] for i in range(len(list1))}
print(dict)
```

### 5. 拆包

对于函数中的多个返回数据  去掉元组 列表 或者字典 直接获取里面数据的过程

**对元组拆包**

```
my_tuple = (1, 3.14, "hello",True)
num, pi, my_str, my_bool = my_list
```

一个元组中有多个元素，当我们想要获取元组中的每一个元素的时候就可以使用拆包获取

![image-20220803225411194](E:\黑马培训\assets\image-20220803225411194.png)

![image-20220803230055903](E:\黑马培训\assets\image-20220803230055903.png)

![image-20220803230215701](E:\黑马培训\assets\image-20220803230215701.png)

![image-20220803230239316](E:\黑马培训\assets\image-20220803230239316.png)

![image-20220803230300224](E:\黑马培训\assets\image-20220803230300224.png)

![image-20220803230350842](E:\黑马培训\assets\image-20220803230350842.png)

![image-20220804104552548](E:\黑马培训\assets\image-20220804104552548.png)

### 6. 组包

![image-20220804104532398](E:\黑马培训\assets\image-20220804104532398.png)

![image-20220804113023446](E:\黑马培训\assets\image-20220804113023446.png)

![image-20220804113040399](E:\黑马培训\assets\image-20220804113040399.png)

### 7. 引用

**id() 可以查看变量的内存地址**

在python中变量的值相同时，在内存中的位置是一样的

![image-20220804113700725](E:\黑马培训\assets\image-20220804113700725.png)

**没有改变原内存的数据，只是把它们的指向改变了**

**函数的引用传递**

在python中，函数调用传递实参都是引用传递

实参传递给形参，让形参等于了实参，简而言之就是让形参的指向和实参的指向相一致，也就是说指向的内存一致

### 8. 可变数据类型和不可变数据类型

![image-20220804114714006](E:\黑马培训\assets\image-20220804114714006.png)

### 9. range() 函数

![image-20220804144630297](E:\黑马培训\assets\image-20220804144630297.png)

### 10 . lambda表达式

就是定义一个函数

![image-20220804151244932](E:\黑马培训\assets\image-20220804151244932.png)

： 后面只能有一行代码，lambda定义的函数没有名字

**代码示例：**

![image-20220804152741515](E:\黑马培训\assets\image-20220804152741515.png)

### 11. 函数名可以作为实参传给形参

例子：![image-20220804153836325](E:\黑马培训\assets\image-20220804153836325.png)

**第二种：lambda匿名表达式**

![image-20220804154431969](E:\黑马培训\assets\image-20220804154431969.png)



![image-20220804160123530](E:\黑马培训\assets\image-20220804160123530.png)

![image-20220804160051821](E:\黑马培训\assets\image-20220804160051821.png)

![image-20220804160332442](E:\黑马培训\assets\image-20220804160332442.png)

**打印出元素下标**

```python
for i, user_dict in enumerate(range(1, 11)):
    print(i, user_dict)
```

### 12. 模块

在Python中一个模块就是一个文件，模块是保存代码的最小单位，在模块中可以声明变量，函数，属性和类等Python代码元素

python模块, 是一个以python文件,以.py结尾,模块能定义函数,类和变量,模块里也能包含可执行的代码

**python中的模块相当于java中的类/接口文件,两者import作用相同,但是python的功能更加强大**

![image-20220806173631447](E:\黑马培训\Python基础笔记\assets\image-20220806173631447.png)

**不知道啥意思的截图**

![image-20220807202100662](E:\黑马培训\Python基础笔记\assets\image-20220807202100662.png)

#### 2.1 模块定义

注意模块定义的名称要与所编写代码的文件名相同

示例：

```python
# my_mould.py  

x = 1
y = '你好'
z = True
```

此时上面就定义了一个名为my_mould.py的模块

#### 2.2 模块导入方式

**import＜模块名＞**：通过这种方式会导入m2模块的所有代码元素，在访问时需要加前缀“m2.”

图示解释：

![image-20220803112543313](E:\黑马培训\Python基础笔记\assets\image-20220803112543313.png)

**from <模块名>import<代码元素>**: 通过这种方式导入m2中的x变量，在访问时不需要加前缀"m2."

![image-20220803113209491](E:\黑马培训\Python基础笔记\assets\image-20220803113209491.png)

**from<模块名>import<代码元素>as<代码元素别名>**: 与2类似，在当前m1模块的代码元素（x变量)与要导入的m2模块的代码元素(x变量)名称有冲突时,可以给要导入的代码元素(m2 中的 x) 起一个别名x2

![image-20220803113758961](E:\黑马培训\Python基础笔记\assets\image-20220803113758961.png)

import time 和 from time import * 这两种方式都能使用time模块中的所有功能

**区别:  调用函数的格式不同**

前者: 模块名.功能名()   例如 time.sleep(2)

后者: 可以直接写功能(函数名) 例如 sleep(2)

![image-20220806181129910](E:\黑马培训\Python基础笔记\assets\image-20220806181129910.png)

**自定义模块**

![image-20220806182357550](E:\黑马培训\Python基础笔记\assets\image-20220806182357550.png)

![image-20220806182857969](E:\黑马培训\Python基础笔记\assets\image-20220806182857969.png)

```
__all__ = [具体的需要用到的成员]  # 这个是定义在被作为模块的那个文件里的
```

**在被作为模块的.py文件中，如果有写调用函数的测试代码(它没写到main函数中），当你在导入这个模块时，就会让有写调用函数的函数执行**

**如何解决？**

**核心：** 

python中下面的这个属性可以利用print函数来输出

```python
__name__ 属性
# 如果在当前模块中，打印它的值，那就是：__main__
# 如果是在其他模块中，打印它的值，那就是: 该被导入的模块的名字
```

**知道这个属性以后我们就可以来添加一个判断条件**

```python
if __name__ == 'main':
    # 因为__name__只有在当前模块中才是__main__, 到其他模块值都变了
     fun1()
     fun2()
```

**要导入模块中要执行的东西只要没被函数封装，那么它们就会被一一执行**
