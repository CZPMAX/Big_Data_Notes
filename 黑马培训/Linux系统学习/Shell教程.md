[TOC]

# Shell教程（注意：shell语句等号两边都不能有空格）

**Shell中复制多行指令为: 前提光标要放在复制的起始行:  ESC+要复制的行数+yy  接着光标放在复制行的最后一行**

**的末尾按下p键**

# 1. 简介

## 1.1 什么是Shell

- 一个命令解释器

- 一个用C语言编写的可以直接操作Linux内核的程序

- 一种命令编程语言

- shell命令可以启动暂停停止程序对计算机的控制

  ![image-20220827152926879](E:\黑马培训\assets\image-20220827152926879.png)

平时挂在嘴上所说的都是Shell的脚本 (shell script),  是一种为Shell编写的脚本程序

**Shell脚本**

通过shell指令或者程序编程语言编写的Shell文本文件,这就是Shell脚本,也叫Shell程序

学习Shell命令的好处,通过Shell命令与编程语言来提高linux系统的管理工作效率

**Linux 的 Shell 种类众多，常见的有：**

- Bourne Shell（/usr/bin/sh或/bin/sh）
- Bourne Again Shell（/bin/bash）
- C Shell（/usr/bin/csh）
- K Shell（/usr/bin/ksh）
- Shell for Root（/sbin/sh）
- ……

**Shell解析器:**

![image-20220828160051491](E:\黑马培训\assets\image-20220828160051491.png)



在公司中常用的就是Bash, 也就是 Bourne Again Shell, 由于易用和免费,Bash已经在工作中被广泛使用,**同时Bash也是大多数Linux系统默认的Shell**

在一般情况下,人们并不区分Bourne Shell 和 Bourne Again Shell ,所以,像#!/bin/sh  它同样可以改为#!/bin/bash

**#! 告诉系统其后路经 所指定的程序即是解释此脚本文件的Shell程序**

**shell操作linux内核的图解:**

![image-20220828155623846](E:\黑马培训\assets\image-20220828155623846.png)

![image-20220828160018440](E:\黑马培训\assets\image-20220828160018440.png)

## 1.2 查看虚拟机支持的shell

![image-20220828160209689](E:\黑马培训\assets\image-20220828160209689.png)

Centos默认的解析器是bash

语法:

```shell
echo $SHELL
```

含义:打印出当前系统环境使用的Shell解释器类型

echo 用于打印数据到终端

$SHELL是全局共享的环境变量,所有的Shell程序都可以读取到的变量

![image-20220828161716026](E:\黑马培训\assets\image-20220828161716026.png)

## 1.3 小结

1. Shell是命令,类似于Windows的dos命令, 又是一门程序设计语言,里面含有变量,函数,逻辑控制语句等
2. Shell脚本是一个文本文件,里面可以编写Shell命令或进行编程,形成一个可重用执行的脚本文件
3. Shell脚本的作用,通过Shell编程提高对linux系统管理工作效率
4. Linux系统默认的Shell解析器是/bin/bash

# 2. 编写格式与执行方式

## 2.1 脚本文件后缀名规范

Shell脚本文件就是一个文本文件, 后缀名建议使用`.sh`结尾

## 2.2 首行格式规范

首行需要设置Shell解析器的类型,语法

```shell
#!/bin/bash
```

> 含义: 设置当前shell脚本文件采用bash解析器运行脚本代码

## 2.3 注释格式

单行注释

**语法:**

```shell
# 注释内容
```



多行注释

**语法:**

```shell
:<<!
注释内容1
...
注释内容n

!
```

## 2.4 脚本文件执行的三种方式

1. sh解析器执行方式

   语法: sh脚本文件

   介绍: 就是利用sh命令来执行脚本文件,本质就是使用Shell解析器运行脚本文件

   ![image-20220828164216381](E:\黑马培训\assets\image-20220828164216381.png)

2. bash解析器执行方式

   语法: bash脚本文件

   介绍: 就是利用bash命令执行脚本文件,本质就是使用shell解析器运行脚本文件

3. 仅路径执行方式

   语法: ./脚本文件

   介绍: 执行当前目录下的脚本文件

   注意: 脚本文件自己执行需要可以执行的权限,否则无法执行

   **给所有用户添加可执行权限语法:**

   chmod a+x  这里写要执行的脚本文件

**3种方式的区别**

​	sh或者bash执行的脚本文件方式是直接使用Shell解析器运行脚本文件,不需要可执行权限

​	仅路径方式是执行脚本文件自己,需要可以执行的取权限

## 2.5 小结

1.shell脚本文件编写规范?

> 文件的后缀名:建议使用.sh扩展名
>
> 首行需要设置解析器类型 #!/bin/bash
>
> 脚本文件中的注释
>
> ​	单行注释: # 注释内容
>
> ​	多行注释: :<<!

> ​                注释内容
>
> ​                    !

2.执行shell脚本文件有哪三种方式,并说明他们的区别

>  sh执行脚本文件
>
> bash执行脚本文件
>
> 仅路径执行脚本文件
>
> 区别: 前两种是解析器直接执行不需要可执行权限,仅路径执行方式是脚本自身执行,需要执行权限

# 3. 多命令处理

​       目标: 掌握shell脚本文件执行多命令处理

## 3.1 多命令处理介绍

 就是在Shell脚本文件中编写多个Shell命令

**案例需求:**

已知目录/root/itheima目录,执行batch.sh脚本,实现在/root/itheima/目录下创建一个one.txt在one.txt文件中增加内容"Hello Shell"

**注意：**

**mkdir 是创建一个目录**

**touch 是创基一个文件**

**cat 是用来查看数据的**

**步骤分析:**

1. 使用mkdir创建/root/itheima目录

2. 创建脚本文件batch.sh

3. 编辑脚本文件

   3.1 命令1，touch 创建文件，文件名  ===>  /root/itheima/one.txt

   3.2 命令2，输出数据“Hello Shell”到one.txt文件中

   > 输出数据到文件中的命令
   >
   > 数据   >>  文件

   **具体操作流程：**

- 使用mkdir命令创建目录itheima

- 使用touch命令创建脚本文件batch.sh

- 使用vim指令 打开脚本文件batch.sh 进行编写shell程序 具体代码如下

  ![image-20220828173959732](E:\黑马培训\assets\image-20220828173959732.png)

  **执行的时候是在根目录下执行的，好像哪里执行都可以**

  解释：第一条代码告诉linux我使用bash解析器来执行代码

  ​            接着就在itheima目录下创建一个one.txt文本文件

  ​            使用重定向 把数据"Hello Shell"输入one.txt

4. 执行脚本文件

## 3.2 小结

shell脚本文件中是否可以执行多命令处理？

可以，详情见上面例子



# 4. Shell：环境变量

学习目标：理解什么是系统环境变量，掌握常用的系统环境变量都有哪些

> 注意: 所有用户自定义变量在虚拟机关机后,都会被自动释放

## 4.1 Shell 变量的介绍

**内存临时存储的就是变量**

变量用于存储管理临时的数据，这些数据都是在运行内存中的

## 4.2 变量的类型

1. 系统环境变量
2. 自定义变量
3. 特殊符号不变量

## 4.3 系统环境变量

**介绍**

是系统提供的共享变量，是linux系统加载Shell的配置文件中定义的变量共享给所有的Shell程序使用

## 4.4 Shell的配置文件分类

**1.全局配置文件**

/etc/profile

/etc/profile.d/*.sh

/etc/bashrc

**2.个人配置文件**

当前用户/.bash_profile

当前用户/.bashrc

一般情况下，我们都是直接对全局配置进行操作

**环境变量分类**

在linux系统中，环境变量按照其作用范围不同大致可以分为系统环境变量和用户级环境变量

**系统级环境变量**： Shell环境加载全局配置文件中的变量共享给所有用户所用Shell程序使用

**用户级环境变量**： Shell环境变量加载个人配置文件中的变量共享给当前所有的用户

**查看当前Shell系统环境变量**

查看命令

```shell
env
```

![image-20220828230758737](E:\黑马培训\assets\image-20220828230758737.png)

**查看Shell变量(系统环境变量+自定义变量+函数)**

查看命令

```sql
set
```

![image-20220828230700430](E:\黑马培训\assets\image-20220828230700430.png)

**常用系统环境变量**

| 变量名称 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| PATH     | 与windows环境变量PATH功能一样，设置命令的搜索路径，以冒号为分割 |
| HOME     | 当前用户主目录：/root                                        |
| SHELL    | 当前shell解释器类型：/bin/bash                               |
| HISTFILE | 显示当前用户执行命令的历时列表文件：/root/.bash_history      |
| PWD      | 显示当前所在路径： /root                                     |
| OLDPWD   | 显示之前路径                                                 |
| HOSTNAME | 显示当前主机名                                               |
| HOSTTYPE | 显示主机的架构，i386,i686 还是x86 x64等：x86_64              |
| LANG     | 设置当前系统语言环境：zh_CN.UTF-8                            |

上面的变量都要与echo一起使用 $表示当前

格式 echo $SHELL ....

**小结**

1.系统环境变量是什么？

> 是系统提供的环境变量，通过加载Shell配置文件中变量数据共享给Shell程序使用

2.环境变量的分类

> 系统级别环境变量，Shell环境加载全局配置文件中的变量
>
> 用户级环境变量，Shell环境加载个人配置文件中定义的变量

3.env和set区别

> env用于查看系统环境变量
>
> set用于查看系统环境变量+自定义函数+函数

## 4.5 自定义变量

**目标：**

理解自定义变量的分类

理解自定义变量进行增删改查

**介绍：**

就是自己定义的变量

**分类：**

1. 自定义局部变量
2. 自定义常量
3. 自定义全局变量

### 4.5.1 自定义局部变量

#### 1. 介绍

就是定义在一个脚本中的变量，只能在这个脚本文件中使用的变量，就是局部变量

**定义与使用：**

**定义语法：**

```shell
var_name=value
```

#### 2. 变量定义规则

1. 变量名称可以有字母，数字下划线组成，但是不能以数字开头
2. **等号两端不能有空格**
3. 在bash环境中，**变量的默认类型都是字符串数据类型**，无法直接进行数值计算
4. 变量的值如果有空格，必须使用双引号括起来
5. 不能使用Shell的关键字作为变量名称

**演示：**

![image-20220831181019938](E:\黑马培训\assets\image-20220831181019938.png)

**查询变量值语法：**

```shell
# 语法1: 直接使用变量名查询
$var_name #这个意思是变量名称
# 语法2: 使用花括号
${var_name}
# 区别: 花括号的方式适合拼接字符串
```

**注意：** 在输出时都要加入echo 在shell语句的最前面，在变量名前面加$ ，这里的意思是**取变量运算符**  echo相当

于print

**没写echo时报的错：**

![image-20220831181835001](E:\黑马培训\assets\image-20220831181835001.png)

**正常的情况:**

![image-20220831191509467](E:\黑马培训\assets\image-20220831191509467.png)

字符串拼接的意思： 是把字符串里面写上变量然后输出

**示例：**

![image-20220831192100642](E:\黑马培训\assets\image-20220831192100642.png)

Shell中变量的修改，就是直接原来的变量名等于一个新值，没有的话就是重新定义一个变量

**图形示例：**

![image-20220831192904406](E:\黑马培训\assets\image-20220831192904406.png)

**变量删除：**

语法

```shell
unset var_name
```

**图示结果：**

![image-20220831193114418](E:\黑马培训\assets\image-20220831193114418.png)

#### 3. 变量的定义与使用

**定义语法：**

```shell
var_name=value
```

### 4.5.2 自定义常量

**介绍：**

> 就是变量设置后值不能修改的变量叫常量，也叫只读变量

**语法：**

```shell
readonly var_name
```

**演示：**

![image-20220831194100355](E:\黑马培训\assets\image-20220831194100355.png)

### 4.5.3 自定义全局变量

**父子Shell环境介绍**    (父子Shell环境就是在脚本文件中而言，谁先使用对对方谁就是父Shell环境)

例如：有2个Shell脚本文件 A.sh 和 B.sh

如果 在A.sh脚本文件中执行了B.sh脚本文件，那么A.sh就是父Shell环境

B.sh就是子Shell环境

**自定义全局变量介绍**

> 就是在当前脚本文件中定义全局变量，这个全局变量可以在当前Shell环境与子Shell环境中的都可以使用

**自定义全局变量语法**

```shell
export var_name1 var_name2
```

测试全局变量在子Shell中是否可用，在父Shell中是否可用

**测试步骤：**

1. 创建2个脚本文件 demo2.sh 和demo3.sh

2. 编辑demo2.sh

   命令1：定义全局变量VAR4

   命令2：执行demo3.sh脚本文件

3. 编辑demo3.sh

   输出全局变量VAR4

4. 执行demo2.sh父脚本文件

**运行实例：**

![image-20220831200954666](E:\黑马培训\assets\image-20220831200954666.png)

红圈的地方VAR4变量的值还未设为全局变量，所有即使在demo2.sh中引用了demo3.sh，形成了父子Shell环境，子Shell  demo3.sh中也是引用不了变量VAR4的

**图示：**![image-20220831201322956](E:\黑马培训\assets\image-20220831201322956.png)

这时候红圈中定义VAR4为全局变量是还未定义的

定义完以后运行demo2.sh demo3.sh就会输出相应的语句

**demo3.sh中的文件内容：**

![image-20220831202231975](E:\黑马培训\assets\image-20220831202231975.png)

这里的自定义全局变量意思就是在父子Shell环境中。即父子Shell脚本中

子Shell脚本可以使用父Shell脚本中的变量

### 4.5.4 小结

**自定义变量的分类**

> 自定义局部变量：就是在一个脚本文件内部使用var_name=value
>
> 自定义常量：不可以修改值的变量 readonly var_name
>
> 自定义全局变量：设置变量在当前脚本文件中与子Shell环境可以使用的变量 export var_name

自定义变量进行增删改查

> 定义和修改： var_name=value 存在时就是定义，不存在时就是修改
>
> 查询：${var_name} 或 $var_name
>
> 删除：unset var_name

## 4.6 特殊变量（面试会问）

**目标：**

能够说出常用的特殊变量有哪些

**特殊变量：$n**

**语法**

```shell
$n
```

**含义**

```shell
用于接收脚本文件执行时传入的参数
$1~$9 代表获取第一输入参数到9个输入参数
第十个参数及以上获取参数的格式: ${数字} 否则无法获取
```

**执行脚本文件传入参数语法**

```shell
sh 脚本文件 输入参数1 输入产生2 ...
```

**案例需求**

创建脚本文件demo4.sh文件,并在脚本文件内部执行打印脚本文件名字,第一个输入参数,第二个输入参数

**实现步骤**

1. 创建脚本文件demo4.sh
2. 编辑demo4.sh的文件内容

```shell
# 命令1: 打印当前脚本文件名字
# 命令2: 打印第1个输入参数
# 命令3: 打印第2个输入参数
# 命令4: 打印第10个输入参数
```

3. 执行脚本文件demo4.sh

**演示:**

1. 创建demo4.sh文件

   ![image-20220831211247721](E:\黑马培训\assets\image-20220831211247721.png)

2. vim配置demo4.sh文件

​                                                         ![image-20220901183258902](E:\黑马培训\assets\image-20220901183258902.png)

3. 运行demo4.sh脚本文件,此时没有输入参数,则没有显示

![image-20220901183353651](E:\黑马培训\assets\image-20220901183353651.png)

4. 输入对应的10个参数运行 demo4.sh shell脚本文件

![image-20220901183457397](E:\黑马培训\assets\image-20220901183457397.png)

**特殊变量 $#**

**语法**

```shell
$#
```

**含义**

获取所有输入参数的个数

**案例需求**

在demo4.sh中输出输入参数的个数

**演示**

编辑demo4.sh输入输出参数个数

![image-20220901183826535](E:\黑马培训\assets\image-20220901183826535.png)

![image-20220901183901862](E:\黑马培训\assets\image-20220901183901862.png)

带**大括号**为了以后的字符串拼接

**结果:**

![image-20220901184146088](E:\黑马培训\assets\image-20220901184146088.png)

**特殊变量: $*, $@**

**语法:**

```shell
$*
$@
# 含义都是获取所有输入参数,用于以后输出所有参数
```

**$*与$@的区别**

```shell
1.不使用双引号括起来,功能一样
 $*与$@获取所有输入参数,格式为: $1 $2 ... $n
2.使用双引号括起来
"$*"获取的所有参数拼接为一个字符串,格式为:"$1 $2 ... $n" 输出就是一行十个字符串
"$@"获取一组参数列表对象,格式为: "$1" "$2" ... "$n" 每个参数都是列表中的一个元素 所以打印的多行,行数取决于元素个数
使用循环打印所有输入参数可以看出区别
```

**循环语法**

```shell
for var in 列表变量
do    # 循环开始
   命令 #循环体
done  # 循环结束
```

**demo4.sh配置代码**

```shell
#!/bin/bash
# 命令1: 打印当前脚本文件名字
echo "当前脚本文件名称:$0"
# 命令2: 打印第1个输入参数
echo "第一个输入参数:$1"
# 命令3: 打印第2个输入参数
echo "第二个输入参数:$2"
# 命令4: 打印第10个输入参数
echo "第十个输入参数不带花括号获取:$10"
echo "第十个输入参数带花括号获取:${10}"
# 命令5 打印所有输入参数的个数
echo "所有输入参数个数:${#}"


# 增加命令:实现直接输出所有输入后参数
echo "使用$*直接输出:$*"
echo "使用$@直接输出:$@"

# 增加命令:使用循环打印输出所有输入参数
echo "循环遍历输出$*所有参数"
for item in "$*"
do
  echo $item
done
echo "循环遍历输出$@所有参数"
for item in "$@"
do
  echo $item
done

```

**运行结果**

![image-20220901190647788](E:\黑马培训\assets\image-20220901190647788.png)

**特殊变量：$?**

**语法**

```
$?
```

**含义**

用于获取上**一个shell命令的退出状态码**，或者是**函数的返回值**

> 每个shell命令的执行都有一个返回值，这个返回值用于说明命令执行是否成功
>
> 一般来说，返回0代表命令执行成功，非0代表命令执行失败

运行结果图示：

![image-20220905194914338](E:\黑马培训\assets\image-20220905194914338.png)

**补充获取当前的所有的Shell进程号**

![image-20220905195458997](E:\黑马培训\assets\image-20220905195458997.png)

**特殊变量：$$**

**语法**

```
$$
```

**含义**

用于获取当前Shell的进程id号

![image-20220905195701345](E:\黑马培训\assets\image-20220905195701345.png)

**小结**

![image-20220905200028168](E:\黑马培训\assets\image-20220905200028168.png)

## 4.7 自定义系统环境变量

**全局配置文件/etc/profile应用场景**

当前用户进入Shell环境初始化的时候会加载全局配置文件/etc/profile里面的环境变量，供给所有的Shell程序

使用，以后只要是所有Shell程序或者命令使用的变量，就可以定义在这个文件中

/etc/profile定义存储自定义全局共享环境变量数据

**创建环境变量步骤**

1. 编辑/etc/profile全局配置文件

   ```shell
   # 增加命令: 定义变量VAR1=VAR1 并导出为环境变量
   # 扩展：vim中的命令模式使用G快速定位到文件末尾位置，使用gg定位到文件首行
   ```

2. 重载配置文件/etc/profile,因为配置文件修改要立刻加载里面数据就要立刻重载 语法

   ```shell
   source /etc/profile
   ```

3. 在Shell环境中读取系统级环境变量VAR1

设置环境变量：

```shell
# 增加命令：定义变量VAR1=VAR1 并导出为环境变量
export VAR1=VAR1
```

![image-20220905202300960](E:\黑马培训\assets\image-20220905202300960.png)

配置完全局变量要source一下，加载数据，这样你在外面才能读到数据，才能使用到更新的数据

**小结**

![image-20220905202739423](E:\黑马培训\assets\image-20220905202739423.png)

# 5. 加载流程原理介绍

## 5.1 Shell工作环境介绍

用户进入linux系统就会初始化Shell环境，这个环境变量会加载全局配置文件和个人配置文件中环境变量，每

个脚本文件都有它自己的Shell环境

## 5.2 Shell工作环境分类

交互式Shell

> 与用户进行交互，互动，效果就是用户输入一个命令，Shell环境立即反馈响应

非交互式Shell

> 不需要用户参与就可以执行多个命令，比如一个脚本文件含有多个命令，直接执行并给出结果

![image-20220905203631387](E:\黑马培训\assets\image-20220905203631387.png)

> 交互模式会一直等待用户输入,输入完还能接着输入
>
> 非交互模式执行完一次就没了

## 5.3 环境变量初始化流程

1. 全局配置文件

   /etc/profile

   /etc/profile.d/*.sh

   /etc/bashrc

2. 个人配置文件

   当前用户/.bash_profile

   当前用户/.bashrc

   环境变量加载初始化过程：

   ![image-20220905204514429](E:\黑马培训\assets\image-20220905204514429.png)

   

![image-20220905204741684](E:\黑马培训\assets\image-20220905204741684.png)

## 5.4 加载流程测试

理解shell环境变量的加载流程测试

能够知道环境变量应该配置在哪里

### 1. 切换Shell环境执行脚本文件介绍

在执行一个脚本文件时可以指定具体Shell环境进行执行脚本文件，这就是切换Shell

执行登录环境执行脚本文件语法

```shell
sh/bash -l/--login 脚本文件
```

> 含义：先执行加载shell非登录环境流程初始化变量，再执行脚本文件

### 2. 测试案例

**需求**

shell登录环境会运行/etc/profile

shell非登录环境会运行/.bashrc

在/etc/profile与/当前用户/.bashrc文件分别设置环境变量数据，然后在shell脚本文件中输出环境变量数据，最后切换不同环境执行shell

脚本文件观察上面的流程运行

**分析**

1. 清理工作，清理/etc/profile文件中VAR1环境变量进行删除，并且重载这个配置文件
2. 编辑/etc/profile ,增加环境变量VAR1=VAR1
3. 编辑/root/.bashrc,增加环境变量 VAR2=VAR2
4. 创建demo1.sh文件，读取环境变量数据进行打印

```shell
# 输出环境变量VAR1
# 输出环境变量VAR2
```

5. 以Shell非登录环境执行demo1.sh脚本文件，观察只会输出VAR2,不会输出VAR1
6. 以Shell登录环境执行demo1.sh脚本文件，观察会输出VAR1和VAR2



5.5 识别Shell环境类型

**目标**

理解如何识别shell登录环境与非登录环境

**为什么要理解非登录shell环境与登录shell环境?**

因为他们两个环境加载shell环境变量的路径不同

**语法**

使用$0识别环境语法

```shell
echo $0
```

> 输出 -bash   代表shell登录环境
>
> 输出  bash   代表shell非登录环境
>
> 注意: 这个$0变量如果用在子shell环境中(shell脚本文件) 输出shell脚本文件本身的文件名

bash命令语法

```shell
bash
```

> bash命令： 用于切换为shell非登录环境

**分析**

1.直接登录系统为shell登录环境（-bash）输出$0，观察输出信息效果

2.使用bash命令切换为非登录环境输出$0 观察输出信息效果

**演示**

直接登录linux系统使用如下命令效果

![image-20220918090206456](E:\黑马培训\Linux系统学习\assets\image-20220918090206456.png)

在脚本文件中写$0, 再利用echo输出，则查看不了shell的环境，输出脚本文件的名字

**编辑shell脚本文件**

![image-20220918090340366](E:\黑马培训\Linux系统学习\assets\image-20220918090340366.png)

**直接输出脚本文件**

![image-20220918090445445](E:\黑马培训\Linux系统学习\assets\image-20220918090445445.png)

bash命令将当前环境转换为shell非登录环境，exit命令退出shell非登录环境，进入shell登陆环境

**操作示例**

![image-20220918090711057](E:\黑马培训\Linux系统学习\assets\image-20220918090711057.png)

![image-20220918090736002](E:\黑马培训\Linux系统学习\assets\image-20220918090736002.png)

## 5.6 详细切换Shell环境

**目标**

理解切换shell环境的命令

**切换shell环境命令介绍**

1.直接登录加载shell登录环境

2.su切换用户加载Shell登录与Shell非登录环境

3.bash加载Shell登录与Shell非登录环境

**切换Shell环境命令演示**

切换环境方式1：直接登录系统

**介绍**

直接在虚拟机上使用用户名与密码登录linux系统或者使用客户端直接连接远程linux系统

**演示**

虚拟机本地直接登录演示

![image-20220918142936836](E:\黑马培训\Linux系统学习\assets\image-20220918142936836.png)

客户端远程采用SSH登录演示

![image-20220918143419243](E:\黑马培训\Linux系统学习\assets\image-20220918143419243.png)



切换环境方式2：su切换用户登录

**命令**

语法1

```shell
su 用户名 --login
或
su 用户名 -l
# 切换到指定用户,加载shell非登录环境变量
```

**图示**

![image-20220918231204206](E:\黑马培训\Linux系统学习\assets\image-20220918231204206.png)

语法2

```shell
su 用户名
# 切换到指定用户, 加载shell非登录环境变量
```

![image-20220918234411724](E:\黑马培训\Linux系统学习\assets\image-20220918234411724.png)



**分析步骤**

1.创建普通用户userA

2.切换到用户userA,使用 -l 加载shell登录环境变量,输出环

境变量$0,观察输出-bash

3.使用exit退出userA

4.切换到用于userA,加载shell非登录环境变量,输出环境变量$0,观察输出bash



**useradd的使用**

![image-20220918232509436](E:\黑马培训\Linux系统学习\assets\image-20220918232509436.png)



**登录 shell 的途径**

了解两种方式之间的区别，就要先了解 shell 的配置文件：

bash 的**配置文件**

~/.bash_profile

~/.bashrc

/etc/profile

/etc/profile.d/*.sh

/etc/bashrc

全局配置文件

个人配置文件

由上可知

bash 的**配置文件**分别为

**profile 类**文件和**bashrc 类**文件：

1.**设定环境变量**。

2.**运行命令或脚本**（登录时运行的脚本）。

profile 类文件作用：bashrc 类文件配置作用：设定本地变量。定义命令别名了解以上配置文件后，则：

**登录式 shell 读取配置** 文件过程：/etc/profile**–>**/etc/profile.d/*.sh**–>**~/.bash_profile **–>**~/.bashrc**–>**/etc/bashrc*

**非登录式 shell读取配置** 文件过程：~/.bashrc**–>**/etc/bashrc**–>**/etc/prodile.d/*.sh

![image-20220918234008143](E:\黑马培训\Linux系统学习\assets\image-20220918234008143.png)

而登录式 shell 和非登录式 shell 的运行形式如下：

登录式 shell：正常通过某终端登录的 shell。su - username。su -l username。

非登录式 shell：su username。

**图形终端**下打开的命令窗口。自动执行的 shell 脚本。

![image-20220918234633636](E:\黑马培训\Linux系统学习\assets\image-20220918234633636.png)

# 6. Shell字符串变量

## 6.1 字符串的三种格式

- 单引号
- 双引号方式 (推荐使用)
- 不用引号方式

![image-20220918234856702](E:\黑马培训\Linux系统学习\assets\image-20220918234856702.png)

 

## 6.2 字符串的3种格式的区别

### 1. 使用单引号`''`的字符串:

任何字符都会原样输出,在其中使用变量是无效的

![image-20220918235536496](E:\黑马培训\Linux系统学习\assets\image-20220918235536496.png)

> 单引号是无法解析变量的,双引号可以解析变量



### 2. 由双引号`""`包围的字符串

其中包含了变量,那么该变量会被解析得到值,而不是原样输出

字符串中还可以出现**双引号的字符串,但是需要转义**

![image-20220919000020287](E:\黑马培训\Linux系统学习\assets\image-20220919000020287.png)

> 引号内的变量后必须加\  引号外变量开头也要加\ 这
>
> 是打印双引号

![image-20220919000522078](E:\黑马培训\Linux系统学习\assets\image-20220919000522078.png)



### 3. 不被引号包围的字符串

不被引号包围的字符串中出现变量时也会被解析,这一点与双引号很包含的字符串一样

字符串中不能出现空格,否则空格后面的字符串会作为其他命令解析

![image-20220919000814463](E:\黑马培训\Linux系统学习\assets\image-20220919000814463.png)

![image-20220919000919300](E:\黑马培训\Linux系统学习\assets\image-20220919000919300.png)

![image-20220919001009698](E:\黑马培训\Linux系统学习\assets\image-20220919001009698.png)

> 不加双引号时,虽然也能解析出变量,但是不能有空格在变量与后面的字符串之间,否则shell会将后面的字符串当做指令来执行,如果有这个指令则不会报错,没有会报错,大部分情况下是都没有的



## 6.3 获取字符串的长度

**语法**

```shell
${#字符串变量名}
```

**含义**

获取字符串的字符长度

**演示**

![image-20220919001505155](E:\黑马培训\Linux系统学习\assets\image-20220919001505155.png)

**小结**

![image-20220919001618905](E:\黑马培训\Linux系统学习\assets\image-20220919001618905.png)



## 6.4 字符串变量拼接

**拼接的方式**

1.无符号拼接

2.双引号拼接

3.混合拼接

![image-20220919002144850](E:\黑马培训\Linux系统学习\assets\image-20220919002144850.png)

**混合拼接**

![image-20220919002334659](E:\黑马培训\Linux系统学习\assets\image-20220919002334659.png)

![image-20220919002351720](E:\黑马培训\Linux系统学习\assets\image-20220919002351720.png)

## 6.5 字符串截取

**目标**

掌握shell字符串截取的常用格式

**语法**

| 格式                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| ${变量名:start:length}   | 从string字符串的左边第start个字符开始，<br>向右截取length个字符，start从0开始 |
| ${变量名:start}          | 从string字符串的左边第start个字符开始截取，直到最后          |
| ${变量名:0-start:length} | 从string字符串的右边第start个字符开始<br>向右截取length个的字符，start从1开始，代表右侧第一个字符 |
| ${变量名:0-start}        | 从string字符串的右边第start个字符开始截取，直到最后          |
| ${变量名#*chars}         | 从string字符串左边第一次出现*chars的位置开始<br>截取*`*chars`右边的所有字符 |
| ${变量名##*chars}        | 从string字符串左边最后一次出现`*chars`的位置开始<br>截取*chars右边的所有字符 |
| ${变量名%chars*}         | 从string字符串右边第一次出现`chars*`的位置开始<br>截取chars*左边的所有字符 |
| ${变量名%%chars*}        | 从string字符串右边最后一次出现`chars*`的位置开始<br>截取`chars*`左边 |

**样例练习**

字符串“welcome to itheima”

**从左侧第0个开始，向左截取2个字符**

<img src="E:\黑马培训\Linux系统学习\assets\image-20220919203352933.png" alt="image-20220919203352933" style="zoom:150%;" />



**从左侧第11个开始，向左截取所有字符**

![image-20220919204157356](E:\黑马培训\Linux系统学习\assets\image-20220919204157356.png)



**从右侧第五个开始，向右截取2个字符**

![image-20220919204331350](E:\黑马培训\Linux系统学习\assets\image-20220919204331350.png)



**截取左边第一次出现字符e右边所有的字符**

![image-20220919204512636](E:\黑马培训\Linux系统学习\assets\image-20220919204512636.png)



**截取左边最后一次出现字符e右边的所有字符**

![image-20220919204701044](E:\黑马培训\Linux系统学习\assets\image-20220919204701044.png)



**截取右边第一次出现字符e左边的所有字符**

![image-20220919205214212](E:\黑马培训\Linux系统学习\assets\image-20220919205214212.png)



**截取右边最后一次出现字符e左边的所有字符**

![image-20220919205338636](E:\黑马培训\Linux系统学习\assets\image-20220919205338636.png)



总结：关于左右两边，截取第一次（最后一次）出现字符的右左方向全部的字符的简化口诀 

 左钱（$）右摆（%）, 前取右边所有字符，后取左边所有字符

| 格式                   | 说明                                             |
| ---------------------- | ------------------------------------------------ |
| ${变量名:start:length} | 从左边start位置开始截取length个字符长度，从0开始 |
| ${变量名:start}        | 从左边start位置开始截                            |

## 6.6 Shell索引数组变量: 定义 - 获取 - 拼接

**技能掌握**

1.能够定义shell数组

2.能够获取shell数组数据

3.能够进行shell数组拼接。删除



**介绍**

shell支持数组（array）数组是若干数据的集合，其中的每一份数据都称为数组的元素

> 注意Bash Shell只支持一维数组，不支持多维数组



**数组的定义**

**语法**

在shell中，用括号（）来表示数组，数组元素之间用空格来分隔，语法为

```shell
array_name=(item item2 ...) # 方式1
array_name=([索引下标1]=item1 [索引下标2]=item2 ...) # 方式2
```

> 注意 赋值号=两边不能有空格

![image-20220920001407569](E:\黑马培训\Linux系统学习\assets\image-20220920001407569.png)

![image-20220920001804905](E:\黑马培训\Linux系统学习\assets\image-20220920001804905.png)

> 注意利用索引下标来创建数组的话,根据下标取值如果取到没有赋值的下标元素,那么值为空

1.通过下标获取元素值，index从0开始

```shell
${arr[index]}
```

> 注意使用 {}

![image-20220920002009792](E:\黑马培训\Linux系统学习\assets\image-20220920002009792.png)

2.获取值同时复制给其他变量

```shell
item=${arr[index]}
```

![image-20220920002109953](E:\黑马培训\Linux系统学习\assets\image-20220920002109953.png)

3.使用`@`或`*`可以获取数组中的所有元素

```shell
${arr[0]}
${arr[*]}
```

![image-20220920002130282](E:\黑马培训\Linux系统学习\assets\image-20220920002130282.png)

4.获取数组的长度或者个数

```shell
${#arr[0]}
${#arr[*]}
```

![image-20220920002145734](E:\黑马培训\Linux系统学习\assets\image-20220920002145734.png)

![image-20220920002158581](E:\黑马培训\Linux系统学习\assets\image-20220920002158581.png)

5.获取数组指定元素的字符长度

```shell
${#arr[索引]}
```

![image-20220920002301753](E:\黑马培训\Linux系统学习\assets\image-20220920002301753.png)

![image-20220920002237582](E:\黑马培训\Linux系统学习\assets\image-20220920002237582.png)



**数组拼接**

> 把两个数组拼接到一起

**语法**

使用`@`和`*`获取数组所有元素之后进行拼接

```shell
array_new=(${array[@]} ${arrary[@]} ...)
array_new=(${array[*]} ${arrary[*]} ...)
```

**演示**

![image-20220920010642461](E:\黑马培训\Linux系统学习\assets\image-20220920010642461.png)



**数组的删除**

**语法**

删除数组指定元素数据

```shell
unset array_name[index]
```

例子: num2中只有2个元素10与20

![image-20220920011314591](E:\黑马培训\Linux系统学习\assets\image-20220920011314591.png)



删除整个数组

```shell
unset array_name
```

![image-20220920011402041](E:\黑马培训\Linux系统学习\assets\image-20220920011402041.png)

数组已经全部被删除,输出为空

**小结**

![image-20220920011600110](E:\黑马培训\Linux系统学习\assets\image-20220920011600110.png)

![image-20220920011648280](E:\黑马培训\Linux系统学习\assets\image-20220920011648280.png)

# 7. Shell内置命令

> 理解什么是内置命令,能够使用alias内置命令

## 7.1 内置命令介绍

Shell内置命令,就是由Bash Shell自身提供的命令,而不是文件系统中的可执行文件

使用type来确定一个命令是否是内置命令

```shell
type 命令
```

![image-20220920013114224](E:\黑马培训\Linux系统学习\assets\image-20220920013114224.png)

> 可执行文件分别为ifconfig crontab

可执行 == > 可以写入,操作,执行,运行等

![image-20221002075635700](E:\黑马培训\Linux系统学习\assets\image-20221002075635700.png)

![image-20221002081311031](E:\黑马培训\Linux系统学习\assets\image-20221002081311031.png)

==shell内置命令==

![image-20221002081359713](E:\黑马培训\Linux系统学习\assets\image-20221002081359713.png)

![image-20221002081427602](E:\黑马培训\Linux系统学习\assets\image-20221002081427602.png)

![image-20221002081454901](E:\黑马培训\Linux系统学习\assets\image-20221002081454901.png)

![image-20221002081609717](E:\黑马培训\Linux系统学习\assets\image-20221002081609717.png)

![image-20221002081651272](E:\黑马培训\Linux系统学习\assets\image-20221002081651272.png)

## 7.2 alias设置别名

![image-20221002081709633](E:\黑马培训\Linux系统学习\assets\image-20221002081709633.png)

定义语法：

```shell
alias 别名="命令"
```

> 这里使用单双引号都行



==别名删除语法==

删除指定别名

```shell
unalias 别名
```

删除当前shell环境之中的所有的别名

```shell
unalias -a
```

> 这两种方式都是临时删除当前的shell的别名，想要永久删除就必须去配置文件中手动删除



==alias操作演示==

ps -aux 显示所有的进程，命令

可以给这个命令起一个简短的别名，如下所示

**新建alias别名**

![image-20221002082740147](E:\黑马培训\Linux系统学习\assets\image-20221002082740147.png)

![image-20221002082534826](E:\黑马培训\Linux系统学习\assets\image-20221002082534826.png)

**删除alias别名**

![image-20221002083020492](E:\黑马培训\Linux系统学习\assets\image-20221002083020492.png)

![image-20221002083126738](E:\黑马培训\Linux系统学习\assets\image-20221002083126738.png)

## 7.2 echo输出字符串

![image-20221002090442318](E:\黑马培训\Linux系统学习\assets\image-20221002090442318.png)



**echo输出语法**

默认输出换行语法

```shell
echo 字符串
```



输出不换行语法

```shell
echo -n 字符串
```



**输出演示**

1. 创建echo1.sh文件

```shell
touch echo1.sh
```

2. 编辑文件并保存

```shell
vim echo1.sh
```

3. 编辑内容

![image-20221002091432407](E:\黑马培训\Linux系统学习\assets\image-20221002091432407.png)

4. 输出结果

![image-20221002091426695](E:\黑马培训\Linux系统学习\assets\image-20221002091426695.png)



**echo输出转义字符**

`\n`转义字符

用于echo输出字符串非结尾处的换行，但是默认echo无法解析`/n`转义符

==演示==

![image-20221002092541080](E:\黑马培训\Linux系统学习\assets\image-20221002092541080.png)



`-e`参数

`-e`参数用于解析转义字符

```
echo -e '字符串中含有转义字符'
```

==演示==

![image-20221002092745266](E:\黑马培训\Linux系统学习\assets\image-20221002092745266.png)

![image-20221002093647321](E:\黑马培训\Linux系统学习\assets\image-20221002093647321.png)

##   7.3 read读取控制台输入

**目标**

![image-20221002094013790](E:\黑马培训\Linux系统学习\assets\image-20221002094013790.png)

**介绍**

![image-20221002094318085](E:\黑马培训\Linux系统学习\assets\image-20221002094318085.png)

**语法**

```
read [-options][var1 var2 ...]
```

> options表示选项，如下表所示: var表示用来存储数据变量，可以有一个，也可以有多个
>
> options和var都是可选的，如果没提供变量名，那么读取数据将存放在环境变量REPLY变量中
>
> $REPLY保存read最后一个读入命令的数据

==options支持的参数==

![image-20221002101744503](E:\黑马培训\Linux系统学习\assets\image-20221002101744503.png)

==演示==

不加后面读取数据存放的变量，默认数据读取后存放在REPLY变量里

![image-20221002101155900](E:\黑马培训\Linux系统学习\assets\image-20221002101155900.png)



加上要存储在哪个变量之中

![image-20221002101231757](E:\黑马培训\Linux系统学习\assets\image-20221002101231757.png)

> 这个read函数用法的解释
>
> 1. 先开启read操作 后面加上数据要存放的变量名，或者不加变量名，直接写read
>
> 2. 接着回车以后，光标闪烁 等待用户输入要存放的数据
> 3. 输入具体数据，回车，这时候数据就被输入到具体的变量中了
> 4. 接着echo就可以输出查看变量中的数据



==示例1 把数据存放在数组之中==

![image-20221002102702075](E:\黑马培训\Linux系统学习\assets\image-20221002102702075.png)

> 把数据存放在数组之中，输入时要使用空格来分开数组的每个元素，下标从0开始

==错误输入示范==

![image-20221002102903196](E:\黑马培训\Linux系统学习\assets\image-20221002102903196.png)

![image-20221002102909047](E:\黑马培训\Linux系统学习\assets\image-20221002102909047.png)

> 没使用空格输入数据 123456被当作数组的第一个元素    1，2，3，4，5，6也是
>
> 注意：输出数组变量时要加中括号 当变量要与字符串进行拼接时 输出就要加中括号
>
> 示例：echo "姓名: ${name}"



==示例2 给多个变量赋值==

![image-20221002103652371](E:\黑马培训\Linux系统学习\assets\image-20221002103652371.png)

![image-20221002103144702](E:\黑马培训\Linux系统学习\assets\image-20221002103144702.png)

==read1.sh脚本文件编辑内容==

![image-20221002103429860](E:\黑马培训\Linux系统学习\assets\image-20221002103429860.png)

==操作输入与输出==

![image-20221002103716624](E:\黑马培训\Linux系统学习\assets\image-20221002103716624.png)



## 7.4 exit退出

**介绍**

`exit`用于退出当前的shell环境进程结束运行，并且可以返回一个状态码，一般使用`$?`可以获取退出状态码



**语法**

退出正确语法

```shell
exit # 默认返回状态码0，一般代表命令执行成功
```



错误退出语法

```shell
exit # 非零数字 数字建议的范围0~255 一般代表命令执行失败
```

 

**exit应用场景**

1. 结束当前shell进程

2. 当shell进程执行出错退出时，可以返回不同状态值代表不同错误

   > 比如打开一个文件时，可以返回
   >
   > ​                                     1 表示文件不存在   
   >
   > ​                                     2 表示文件没有读取权限 
   >
   > ​                                     3 表示文件类型不对



**步骤**

1. 创建exit.sh文件

   > vim exit.sh

2. 编辑exit.sh文件，使用`exit数字`退出结束当前的shell

   ![image-20221006111759408](E:\黑马培训\Linux系统学习\assets\image-20221006111759408.png)

3. 执行文件，打印并返回状态值

   ![image-20221006111818348](E:\黑马培训\Linux系统学习\assets\image-20221006111818348.png)

![image-20221006111826944](E:\黑马培训\Linux系统学习\assets\image-20221006111826944.png)

![image-20221006141510154](E:\黑马培训\Linux系统学习\assets\image-20221006141510154.png)

## 7.5 declare设置变量

![image-20221006142555088](E:\黑马培训\Linux系统学习\assets\image-20221006142555088.png)

![image-20221006142822071](E:\黑马培训\Linux系统学习\assets\image-20221006142822071.png)

![image-20221006142909956](E:\黑马培训\Linux系统学习\assets\image-20221006142909956.png)

**案例操作**

![image-20221006164057104](E:\黑马培训\Linux系统学习\assets\image-20221006164057104.png)

![image-20221006164103577](E:\黑马培训\Linux系统学习\assets\image-20221006164103577.png)

![image-20221006164231328](E:\黑马培训\Linux系统学习\assets\image-20221006164231328.png)
